<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#operations">Operations</a></li>
<li><a href="#operator-laws">Operator laws</a>
<ul>
<li><a href="#associativity">Associativity</a></li>
<li><a href="#commutativity">Commutativity</a></li>
<li><a href="#identity">Identity</a></li>
<li><a href="#elimination">Elimination</a></li>
<li><a href="#inverse">Inverse</a></li>
<li><a href="#distributive">Distributive</a></li>
<li><a href="#absorptive">Absorptive</a></li>
<li><a href="#cancellative">Cancellative</a></li>
<li><a href="#congruence">Congruence</a></li>
</ul></li>
<li><a href="#respecting-an-relation">Respecting an relation</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="operations">Operations</h1>
<p>We start by defining operations and laws these operations obey.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>equality
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>functions
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>product

<span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">using</span> <span class="ot">(</span>Level<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_;</span> lsuc<span class="ot">;</span> lzero<span class="ot">)</span>

<span class="kw">module</span> Algebra<span class="ot">.</span>operations <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="kw">where</span></code></pre></div>
<p>A binary operation <span class="math inline">★</span> on a set A is a function (function type!) that takes two elements of type A and returns an element of A:</p>
<pre class="math"><code>★ : A × A → A</code></pre>
<p>More often the operation is applied to the two objects <code>x, y ∈ A</code> as <span class="math inline"><em>x</em>★<em>y</em></span>.</p>
<p>A unary operation on the other hand operates on only one element of A to return an element of A:</p>
<pre class="math"><code>♠ : A → A</code></pre>
<p>In agda, a homogenous binary operation <code>★ A</code> can be defined as:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  ★<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="dt">Set</span> a
  ★ A <span class="ot">=</span> A <span class="ot">→</span> A <span class="ot">→</span> A</code></pre></div>
<p>and a unary operation as:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  ♠<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="dt">Set</span> a
  ♠ A <span class="ot">=</span> A <span class="ot">→</span> A</code></pre></div>
<h2 id="operator-laws">Operator laws</h2>
<p>We now write a few laws that operators could follow. Essentially, structures built on top of these operators would end up following the same laws as the underlying operator. We have already seen some of these laws in <a href="./Logic.laws.html">laws of boolean algebra</a>, these are universe polymorphism-accounted general versions of those laws.</p>
<h3 id="associativity">Associativity</h3>
<div class="figure">
<img src="associative.png" alt="associative" />
<p class="caption">associative</p>
</div>
<p>Mathematically, given an operation <code>★</code>, it is called associative if:</p>
<pre class="math"><code>∀ x, y, z ∈ A,
operation ★ is associative if:

x ★ (y ★ z) ≡ (x ★ y) ★ z</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  Associative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Associative <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">((</span>x ∙ y<span class="ot">)</span> ∙ z<span class="ot">)</span> == <span class="ot">(</span>x ∙ <span class="ot">(</span>y ∙ z<span class="ot">))</span></code></pre></div>
<h3 id="commutativity">Commutativity</h3>
<div class="figure">
<img src="commutative.png" alt="commutative" />
<p class="caption">commutative</p>
</div>
<p>Commutativity is defined as:</p>
<pre class="math"><code>∀ x, y ∈ A,
operation ★ is commutative if:

x ★ y ≡ y ★ x</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  Commutative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Commutative <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y <span class="ot">→</span> <span class="ot">(</span>x ∙ y<span class="ot">)</span> == <span class="ot">(</span>y ∙ x<span class="ot">)</span></code></pre></div>
<h3 id="identity">Identity</h3>
<div class="figure">
<img src="identity.png" alt="identity" />
<p class="caption">identity</p>
</div>
<pre class="math"><code>∀ x ∈ A,
if id is the identity object of A,

x ★ id ≡ x
id ★ x ≡ x</code></pre>
<p>We treat identity as a pair of right and left identities. This helps in working with non-commutative types as well.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  LeftIdentity <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  LeftIdentity e <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">(</span>e ∙ x<span class="ot">)</span> == x

  RightIdentity <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  RightIdentity e <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">(</span>x ∙ e<span class="ot">)</span> == x

  Identity <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Identity e ∙ <span class="ot">=</span> LeftIdentity e ∙ × RightIdentity e ∙</code></pre></div>
<h3 id="elimination">Elimination</h3>
<div class="figure">
<img src="elimination.png" alt="elimination" />
<p class="caption">elimination</p>
</div>
<pre class="math"><code>∀ x ∈ A,

x ★ 0 ≡ 0
0 ★ x ≡ 0</code></pre>
<p>How does our object interact with <code>0</code>? We define that here.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  LeftZero <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  LeftZero z <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">(</span>z ∙ x<span class="ot">)</span> == z

  RightZero <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  RightZero z <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">(</span>x ∙ z<span class="ot">)</span> == z

  Zero <span class="ot">:</span> A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Zero z ∙ <span class="ot">=</span> LeftZero z ∙ × RightZero z ∙</code></pre></div>
<h3 id="inverse">Inverse</h3>
<div class="figure">
<img src="inverse.png" alt="inverse" />
<p class="caption">inverse</p>
</div>
<pre class="math"><code>∀ x ∈ A, ∃ x⁻¹ ∈ A such that

x ★ x⁻¹ ≡ id

x⁻¹ ★ x ≡ id</code></pre>
<p>Given any unary function <code>_⁻¹</code>, we define what it takes for the function to qualify as an inverse.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  LeftInverse <span class="ot">:</span> A <span class="ot">→</span> ♠ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  LeftInverse e <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">((</span>x ⁻¹<span class="ot">)</span> ∙ x<span class="ot">)</span> == e

  RightInverse <span class="ot">:</span> A <span class="ot">→</span> ♠ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  RightInverse e <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">→</span> <span class="ot">(</span>x ∙ <span class="ot">(</span>x ⁻¹<span class="ot">))</span> == e

  Inverse <span class="ot">:</span> A <span class="ot">→</span> ♠ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Inverse e ⁻¹ ∙ <span class="ot">=</span> LeftInverse e ⁻¹ ∙ × RightInverse e ⁻¹ ∙</code></pre></div>
<h3 id="distributive">Distributive</h3>
<div class="figure">
<img src="distributive.png" alt="distributive" />
<p class="caption">distributive</p>
</div>
<pre class="math"><code>∀ x, y, z ∈ A,
operation ★ is distributive if:

( x ★ y ) ★ z ≡ x ★ y × y ★ z</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>DistributesOverˡ<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  <span class="ot">_</span>*<span class="ot">_</span> DistributesOverˡ <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">=</span>
    <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">(</span>x * <span class="ot">(</span>y + z<span class="ot">))</span> == <span class="ot">((</span>x * y<span class="ot">)</span> + <span class="ot">(</span>x * z<span class="ot">))</span>

  <span class="ot">_</span>DistributesOverʳ<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  <span class="ot">_</span>*<span class="ot">_</span> DistributesOverʳ <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">=</span>
    <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">((</span>y + z<span class="ot">)</span> * x<span class="ot">)</span> == <span class="ot">((</span>y * x<span class="ot">)</span> + <span class="ot">(</span>z * x<span class="ot">))</span>

  <span class="ot">_</span>DistributesOver<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  * DistributesOver + <span class="ot">=</span> <span class="ot">(</span>* DistributesOverˡ +<span class="ot">)</span> × <span class="ot">(</span>* DistributesOverʳ +<span class="ot">)</span></code></pre></div>
<h3 id="absorptive">Absorptive</h3>
<div class="figure">
<img src="absorption.png" alt="absorption" />
<p class="caption">absorption</p>
</div>
<pre class="math"><code>∀ x ∈ A and two operations
 ∙ : A → A → A
 ∘ : A → A → A

operation ∙ absorbs ∘ if:

x ∙ (x ∘ y) ≡ x

and ∘ absorbs ∙ if:
x ∘ (x ∙ y) ≡ x

and if both are satisfied collectively ∙ and ∘ are absorptive.</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>Absorbs<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  <span class="ot">_</span>∙<span class="ot">_</span> Absorbs <span class="ot">_</span>∘<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y <span class="ot">→</span> <span class="ot">(</span>x ∙ <span class="ot">(</span>x ∘ y<span class="ot">))</span> == x

  Absorptive <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Absorptive ∙ ∘ <span class="ot">=</span> <span class="ot">(</span>∙ Absorbs ∘<span class="ot">)</span> × <span class="ot">(</span>∘ Absorbs ∙<span class="ot">)</span></code></pre></div>
<h3 id="cancellative">Cancellative</h3>
<div class="figure">
<img src="cancellation.png" alt="cancellation" />
<p class="caption">cancellation</p>
</div>
<pre class="math"><code>∀ x, y ∈ A
and a function • : A → A → A,

(x • y) == (x • z) ⟹ y == z</code></pre>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  LeftCancellative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  LeftCancellative <span class="ot">_</span>•<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>x • y<span class="ot">)</span> == <span class="ot">(</span>x • z<span class="ot">)</span> <span class="ot">→</span> y == z

  RightCancellative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  RightCancellative <span class="ot">_</span>•<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x<span class="ot">}</span> y z <span class="ot">→</span> <span class="ot">(</span>y • x<span class="ot">)</span> == <span class="ot">(</span>z • x<span class="ot">)</span> <span class="ot">→</span> y == z

  Cancellative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Cancellative <span class="ot">_</span>•<span class="ot">_</span> <span class="ot">=</span> LeftCancellative <span class="ot">_</span>•<span class="ot">_</span> × RightCancellative <span class="ot">_</span>•<span class="ot">_</span></code></pre></div>
<h3 id="congruence">Congruence</h3>
<div class="figure">
<img src="congruence.png" alt="congruence" />
<p class="caption">congruence</p>
</div>
<pre class="math"><code>Given
  a₁, a₂ ∈ A
  b₁ b₂ ∈ B
  ∙ : A → B,

if a₁ ≡ a₂,
   b₁ = ∙ a₁
   b₂ = ∙ a₂
then b₁ ≡ b₂</code></pre>
<p>A congruent relation preserves equivalences:</p>
<ul>
<li>for binary relation <code>♣</code>, if <span class="math inline">(<em>x</em>₁,<em>y</em>₁) = =(<em>x</em>₂,<em>y</em>₂)</span> then <span class="math inline">(<em>x</em>₁♣<em>y</em>₁) = =(<em>x</em>₂♣<em>y</em>₂)</span>.</li>
<li>for unary relation <code>♡</code>, if <span class="math inline"><em>x</em> = =<em>y</em></span> then <span class="math inline">♡<em>x</em> = =♡<em>y</em></span>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  Congruent₁ <span class="ot">:</span> ♠ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Congruent₁ f <span class="ot">=</span> f Preserves <span class="ot">_</span>==<span class="ot">_</span> ⟶ <span class="ot">_</span>==<span class="ot">_</span>

  Congruent₂ <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  Congruent₂ ∙ <span class="ot">=</span> ∙ Preserves₂ <span class="ot">_</span>==<span class="ot">_</span> ⟶ <span class="ot">_</span>==<span class="ot">_</span> ⟶ <span class="ot">_</span>==<span class="ot">_</span>

  LeftCongruent <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  LeftCongruent <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(_</span>∙ x<span class="ot">)</span> Preserves <span class="ot">_</span>==<span class="ot">_</span> ⟶ <span class="ot">_</span>==<span class="ot">_</span>

  RightCongruent <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  RightCongruent <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>x ∙<span class="ot">_)</span> Preserves <span class="ot">_</span>==<span class="ot">_</span> ⟶ <span class="ot">_</span>==<span class="ot">_</span></code></pre></div>
<h2 id="respecting-an-relation">Respecting an relation</h2>
<p>We finally define what we mean by a functions “respects” an operation or is invariant of it. For a function <span class="math inline"><em>f</em></span> and an operation <span class="math inline">∘</span>, if <span class="math inline"><em>x</em> ∘ <em>y</em> ⟹ <em>f</em>(<em>x</em>)∘<em>f</em>(<em>y</em>)</span>, we say the function <span class="math inline"><em>f</em></span> respects the operation <span class="math inline">∘</span>. We define two versions of this utility here</p>
<ul>
<li><code>_Respects_</code> for already commutative laws</li>
<li><code>_Respects₂_</code> which combines left <code>_Respectsˡ_</code> and right <code>_Respectsʳ_</code> laws</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>Respects<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
          <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> <span class="dt">Set</span> ℓ₁<span class="ot">)</span>
          <span class="ot">→</span> Rel A ℓ₂
          <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  P Respects <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x y<span class="ot">}</span> <span class="ot">→</span> x ∼ y <span class="ot">→</span> P x <span class="ot">→</span> P y

  <span class="ot">_</span>Respectsʳ<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
          <span class="ot">→</span> Rel A ℓ₁
          <span class="ot">→</span> Rel A ℓ₂
          <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  P Respectsʳ <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>P x<span class="ot">)</span> Respects <span class="ot">_</span>∼<span class="ot">_</span>

  <span class="ot">_</span>Respectsˡ<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
          <span class="ot">→</span> Rel A ℓ₁
          <span class="ot">→</span> Rel A ℓ₂
          <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  P Respectsˡ <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>flip P y<span class="ot">)</span> Respects <span class="ot">_</span>∼<span class="ot">_</span>

  <span class="ot">_</span>Respects₂<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
          <span class="ot">→</span> Rel A ℓ₁
          <span class="ot">→</span> Rel A ℓ₂
          <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span>
  P Respects₂ <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> <span class="ot">(</span>P Respectsʳ <span class="ot">_</span>∼<span class="ot">_)</span> × <span class="ot">(</span>P Respectsˡ <span class="ot">_</span>∼<span class="ot">_)</span></code></pre></div>
<hr />
<p><a href="./Algebra.equational.html">Equational Reasoning</a></p>
</body>
</html>
