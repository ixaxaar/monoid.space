<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AppliedTypes/godels_t</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="AppliedTypes.introduction.html">Previous</a> <a
href="AppliedTypes.system_f.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#g%C3%B6dels-t">Gödel’s T</a>
<ul>
<li><a href="#binary-operations">Binary operations</a></li>
<li><a href="#prime-numbers">Prime numbers</a></li>
<li><a href="#definability">Definability</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="gödels-t">Gödel’s T</h1>
<pre class="agda"><code>open import Types.relations renaming (¬_ to ¬-eq_)
open import Types.equality
open import Level using (0ℓ)
open import Types.product using (_∪_)

module AppliedTypes.godels_t where</code></pre>
<p>“Gödel’s T”, also known as “System T”, named after the mathematician <a
href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del">Kurt Gödel</a>, is a formal system designed by Gödel to provide a
consistency proof of arithmetic. This system includes a type system based on booleans and natural numbers and allows
primitive recursion.</p>
<p>System T basically consists of natural numbers:</p>
<pre class="agda"><code>data ℕ : Set where
  zero : ℕ
  succ : ℕ → ℕ</code></pre>
<p>booleans:</p>
<pre class="agda"><code>data Bool : Set where
  true  : Bool
  false : Bool</code></pre>
<p>if-then-else:</p>
<pre class="agda"><code>if_then_else_ : {C : Set} → Bool → C → C → C
if true  then x else y = x
if false then x else y = y</code></pre>
<p>and recursion on natural numbers:</p>
<pre class="agda"><code>recₙ : {x : Set} → x → (ℕ → x → x) → ℕ → x
recₙ p h  zero    = p
recₙ p h (succ n) = h n (recₙ p h n)</code></pre>
<h2 id="binary-operations">Binary operations</h2>
<p>Addition and multiplication on natural numbers can be defined via recursion:</p>
<pre class="agda"><code>_+_ : ℕ → ℕ → ℕ
_+_ n m = recₙ m (λ x y → succ y) n

_*_ : ℕ → ℕ → ℕ
_*_ n m = recₙ zero (λ x y → y + m) n

-- opposite direction of succ
prev : ℕ → ℕ
prev n = recₙ n (λ x y → x) n

_−_ : ℕ → ℕ → ℕ
_−_ n m = recₙ n (λ x y → (prev y)) m

data _≤_ : Rel ℕ 0ℓ where
  z≤n : ∀ {n}                 → zero  ≤ n
  s≤s : ∀ {m n} (m≤n : m ≤ n) → succ m ≤ succ n

_&lt;_ : Rel ℕ 0ℓ
m &lt; n = succ m ≤ n

_&gt;_ : Rel ℕ 0ℓ
m &gt; n = n &lt; m</code></pre>
<p>Boolean operators can be built on top of if-then-else:</p>
<pre class="agda"><code>¬ : Bool → Bool
¬ b = if b then false else true

_∧_ : Bool → Bool → Bool
a ∧ b = if a then b else false

_∨_ : Bool → Bool → Bool
a ∨ b = if a then true else b

_⊕_ : Bool → Bool → Bool
a ⊕ b = if a then (¬ b) else b</code></pre>
<h2 id="prime-numbers">Prime numbers</h2>
<p>A prime number is defined as a natural number with only two divisors - <code>1</code> and itself.</p>
<pre class="agda"><code>-- divisibility
infix 4 _∣_ _∤_

record _∣_ (m n : ℕ) : Set where
  constructor divides
  field
    quotient : ℕ
    equality : n ≡ quotient * m
open _∣_ using (quotient) public

_∤_ : Rel ℕ 0ℓ
m ∤ n = ¬-eq (m ∣ n)</code></pre>
<p>Prime number definition:</p>
<pre class="agda"><code>record Prime (p : ℕ) : Set where
  constructor prime
  field
    -- primes &gt; 2
    p&gt;1 : p &gt; (succ zero)
    -- only 2 divisors - 1 and p
    isPrime  : ∀ {d} → d ∣ p → (d ≡ (succ zero)) ∪ (d ≡ p)</code></pre>
<h2 id="definability">Definability</h2>
<p>A function $ f : ℕ → ℕ $ is definable if one can find an expression <code>e</code> of <code>f</code> such that:</p>
<pre class="math"><code>∀ x ∈ ℕ, f(x) ≡ e(x)</code></pre>
<p>or in other words, if one can implement the function in system T using only if-then-else and primitive recursion.</p>
<p>If we were to assign a natural number to each such implementation of every function possible, we can treat each
expression as data:</p>
<pre class="sakdeagda"><code>count = zero
one = succ zero

assign : (ℕ → ℕ) → ℕ
assign f = count + one</code></pre>
<hr />
<p><a href="./AppliedTypes.real.html">System F</a></p>
</body>
</html>
