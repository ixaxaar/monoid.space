<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#groups-and-family">Groups and family</a></li>
<li><a href="#conditions">Conditions</a></li>
<li><a href="#magma">Magma</a></li>
<li><a href="#semigroupoid">Semigroupoid</a></li>
<li><a href="#small-category">Small category</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#groupoid">Groupoid</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#commutative-monoid">Commutative Monoid</a></li>
<li><a href="#group">Group</a></li>
<li><a href="#abelian-group">Abelian Group</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="groups-and-family">Groups and family</h1>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>equality <span class="kw">renaming</span> <span class="ot">(</span>refl <span class="kw">to</span> ≡-refl<span class="ot">)</span>
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>functions
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>typeBasics

<span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">using</span> <span class="ot">(</span>Level<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_;</span> lsuc<span class="ot">;</span> lzero<span class="ot">)</span>

<span class="kw">module</span> Algebra<span class="ot">.</span>groups <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="kw">where</span>

  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>operations <span class="ot">(_</span>==<span class="ot">_)</span></code></pre></div>
<p>Algebraic structures, studied in the field of abstract algebra, can be thought of to be generated by varying which ones from a bunch of laws or axioms we choose to apply i.e. <code>totality</code>, <code>associativity</code>, <code>identity</code>, <code>iverse</code> and <code>commutativity</code>.</p>
<table>
<thead>
<tr class="header">
<th>Object ↓ Laws →</th>
<th>Totality</th>
<th>Associativity</th>
<th>Identity</th>
<th>Invertibility</th>
<th>Commutativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Magma</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Semigroupoid</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Small Category</td>
<td></td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Quasigroup</td>
<td>★</td>
<td></td>
<td></td>
<td>★</td>
<td></td>
</tr>
<tr class="odd">
<td>Loop</td>
<td>★</td>
<td></td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr class="even">
<td>Semigroup</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Inverse Semigroup</td>
<td>★</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
</tr>
<tr class="even">
<td>Groupoid</td>
<td></td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr class="odd">
<td>Monoid</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Group</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr class="odd">
<td>Abelian group</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
</tr>
</tbody>
</table>
<p>Some of these objects can be visualized as if they were successors of each other, with the ones at the bottom more “strict” as in with more restrictions in the form of supported laws. We also code them this way below.</p>
<div class="figure">
<img src="./algebra_structure.png" alt="algebra-structure" />
<p class="caption">algebra-structure</p>
</div>
<p>As we see above, semigroupoid is a generalization of the semigroup, group is a stricter form of a monoid or all groups are also monoids etc. Semigroupoids, Small Categories and Groupoids form what is called as partial abstract algebra such that they dont require the totality axiom which thus allows their operations to be partial functions.</p>
<h2 id="conditions">Conditions</h2>
<p>Here we encode the conditions for any given binary operation <code>_∙_</code> or operation-object pair to satisfy being an algebraic object. We define the actual objects in the next section.</p>
<h2 id="magma">Magma</h2>
<p>A magma is a set of objects with an equivalence relation defined on them. It is one of the simplest objects in abstract algebra.</p>
<div class="figure">
<img src="./magma.png" alt="magma" />
<p class="caption">magma</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsMagma <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isEquivalence <span class="ot">:</span> IsEquivalence <span class="ot">_</span>==<span class="ot">_</span>
      ∙-cong        <span class="ot">:</span> Congruent₂ ∙

    <span class="kw">open</span> IsEquivalence isEquivalence <span class="kw">public</span>

    ∙-congˡ <span class="ot">:</span> LeftCongruent ∙
    ∙-congˡ y==z <span class="ot">=</span> ∙-cong y==z rfl

    ∙-congʳ <span class="ot">:</span> RightCongruent ∙
    ∙-congʳ y==z <span class="ot">=</span> ∙-cong rfl y==z</code></pre></div>
<h2 id="semigroupoid">Semigroupoid</h2>
<p>A semigroupoid is a set of objects some of which support an operation <code>★</code>, which must be associative.</p>
<div class="figure">
<img src="semigroupoid.png" alt="semigroupoid" />
<p class="caption">semigroupoid</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsSemigroupoid <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isEquivalence <span class="ot">:</span> IsEquivalence <span class="ot">_</span>==<span class="ot">_</span>
      ∙-cong        <span class="ot">:</span> Congruent₂ ∙
      assoc         <span class="ot">:</span> Associative ∙

    <span class="kw">open</span> IsEquivalence isEquivalence <span class="kw">public</span>

    ∙-congˡ <span class="ot">:</span> LeftCongruent ∙
    ∙-congˡ y==z <span class="ot">=</span> ∙-cong y==z rfl

    ∙-congʳ <span class="ot">:</span> RightCongruent ∙
    ∙-congʳ y==z <span class="ot">=</span> ∙-cong rfl y==z</code></pre></div>
<h2 id="small-category">Small category</h2>
<p>A small category suports identities and the operation supports the identity function. Apart from that, it inherits all properties of a semigroupoid.</p>
<div class="figure">
<img src="smallcategory.png" alt="smallcategory" />
<p class="caption">smallcategory</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsSmallCategory <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isSemigroupoid    <span class="ot">:</span> IsSemigroupoid ∙
      identity          <span class="ot">:</span> Identity x ∙

    <span class="kw">open</span> IsSemigroupoid isSemigroupoid <span class="kw">public</span>

    identityˡ <span class="ot">:</span> LeftIdentity x ∙
    identityˡ <span class="ot">=</span> fst identity

    identityʳ <span class="ot">:</span> RightIdentity x ∙
    identityʳ <span class="ot">=</span> snd identity</code></pre></div>
<h2 id="semigroup">Semigroup</h2>
<p>A semigroup is a structure where the operation is associative. It differs with semigroupoids as in the operation for semigroups are total (or cannot be partial). Hence, semigroupoids are a generalization of semigroups. Semigroups are essentially semigroupoids with the totality condition.</p>
<div class="figure">
<img src="semigroup.png" alt="semigroup" />
<p class="caption">semigroup</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsSemigroup <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isMagma <span class="ot">:</span> IsMagma ∙
      assoc   <span class="ot">:</span> Associative ∙

    <span class="kw">open</span> IsMagma isMagma <span class="kw">public</span></code></pre></div>
<h2 id="groupoid">Groupoid</h2>
<p>A groupoid is a small category with the restriction that the operation has have its inverse defined.</p>
<div class="figure">
<img src="groupoid.png" alt="groupoid" />
<p class="caption">groupoid</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsGroupoid <span class="ot">(_</span>∙<span class="ot">_</span> <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">(_</span>⁻¹ <span class="ot">:</span> ♠ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isSmallCategory   <span class="ot">:</span> IsSmallCategory <span class="ot">_</span>∙<span class="ot">_</span> x
      inverse           <span class="ot">:</span> Inverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>

    <span class="kw">open</span> IsSmallCategory isSmallCategory <span class="kw">public</span>

    inverseˡ <span class="ot">:</span> LeftInverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>
    inverseˡ <span class="ot">=</span> fst inverse

    inverseʳ <span class="ot">:</span> RightInverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>
    inverseʳ <span class="ot">=</span> snd inverse

    <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>equational
    <span class="kw">open</span> withCongruence <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">_</span>⁻¹ rfl trans sym ∙-cong x <span class="kw">public</span>

    <span class="co">-- uniqueness of the inverses</span>
    uniqueˡ-⁻¹ <span class="ot">:</span> <span class="ot">∀</span> α β <span class="ot">→</span> <span class="ot">(</span>α ∙ β<span class="ot">)</span> == x <span class="ot">→</span> α == <span class="ot">(</span>β ⁻¹<span class="ot">)</span>
    uniqueˡ-⁻¹ <span class="ot">=</span> assoc+id+invʳ⇒invˡ-unique assoc identity inverseʳ

    uniqueʳ-⁻¹ <span class="ot">:</span> <span class="ot">∀</span> α β <span class="ot">→</span> <span class="ot">(</span>α ∙ β<span class="ot">)</span> == x <span class="ot">→</span> β == <span class="ot">(</span>α ⁻¹<span class="ot">)</span>
    uniqueʳ-⁻¹ <span class="ot">=</span> assoc+id+invˡ⇒invʳ-unique assoc identity inverseˡ</code></pre></div>
<h2 id="monoid">Monoid</h2>
<p>A monoid is a structure formed by adding the totality condition to small categories.</p>
<div class="figure">
<img src="monoid.png" alt="monoid" />
<p class="caption">monoid</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsMonoid <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isSemigroup <span class="ot">:</span> IsSemigroup ∙
      identity    <span class="ot">:</span> Identity x ∙

    <span class="kw">open</span> IsSemigroup isSemigroup <span class="kw">public</span>

    identityˡ <span class="ot">:</span> LeftIdentity x ∙
    identityˡ <span class="ot">=</span> fst identity

    identityʳ <span class="ot">:</span> RightIdentity x ∙
    identityʳ <span class="ot">=</span> snd identity</code></pre></div>
<h2 id="commutative-monoid">Commutative Monoid</h2>
<p>A commutative monoid is a monoid with its operation required to be commutative.</p>
<div class="figure">
<img src="group.png" alt="group" />
<p class="caption">group</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsCommutativeMonoid <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isSemigroup <span class="ot">:</span> IsSemigroup ∙
      identityˡ   <span class="ot">:</span> LeftIdentity x ∙
      identityʳ   <span class="ot">:</span> RightIdentity x ∙
      comm        <span class="ot">:</span> Commutative ∙

    <span class="kw">open</span> IsSemigroup isSemigroup <span class="kw">public</span>

    identity <span class="ot">:</span> Identity x ∙
    identity <span class="ot">=</span> <span class="ot">(</span>identityˡ , identityʳ<span class="ot">)</span>

    isMonoid <span class="ot">:</span> IsMonoid ∙ x
    isMonoid <span class="ot">=</span> <span class="kw">record</span>
      <span class="ot">{</span> isSemigroup <span class="ot">=</span> isSemigroup
      <span class="ot">;</span> identity    <span class="ot">=</span> identity
      <span class="ot">}</span></code></pre></div>
<h2 id="group">Group</h2>
<p>A group is a monoid with requiring for inverses to exist for every pair of elements. A groupoid is a generalization of groups by removing the totality restriction.</p>
<div class="figure">
<img src="group.png" alt="group" />
<p class="caption">group</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsGroup <span class="ot">(_</span>∙<span class="ot">_</span> <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">(_</span>⁻¹ <span class="ot">:</span> ♠ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isMonoid  <span class="ot">:</span> IsMonoid <span class="ot">_</span>∙<span class="ot">_</span> x
      inverse   <span class="ot">:</span> Inverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>
      ⁻¹-cong   <span class="ot">:</span> Congruent₁ <span class="ot">_</span>⁻¹

    <span class="kw">open</span> IsMonoid isMonoid <span class="kw">public</span>

    <span class="kw">infixl</span> <span class="dv">7</span> <span class="ot">_</span>-<span class="ot">_</span>
    <span class="ot">_</span>-<span class="ot">_</span> <span class="ot">:</span> ★ A
    x - y <span class="ot">=</span> x ∙ <span class="ot">(</span>y ⁻¹<span class="ot">)</span>

    inverseˡ <span class="ot">:</span> LeftInverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>
    inverseˡ <span class="ot">=</span> fst inverse

    inverseʳ <span class="ot">:</span> RightInverse x <span class="ot">_</span>⁻¹ <span class="ot">_</span>∙<span class="ot">_</span>
    inverseʳ <span class="ot">=</span> snd inverse

    <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>equational
    <span class="kw">open</span> withCongruence <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">_</span>⁻¹ rfl trans sym ∙-cong x <span class="kw">public</span>

    <span class="co">-- uniqueness of the inverses</span>
    uniqueˡ-⁻¹ <span class="ot">:</span> <span class="ot">∀</span> α β <span class="ot">→</span> <span class="ot">(</span>α ∙ β<span class="ot">)</span> == x <span class="ot">→</span> α == <span class="ot">(</span>β ⁻¹<span class="ot">)</span>
    uniqueˡ-⁻¹ <span class="ot">=</span> assoc+id+invʳ⇒invˡ-unique assoc identity inverseʳ

    uniqueʳ-⁻¹ <span class="ot">:</span> <span class="ot">∀</span> α β <span class="ot">→</span> <span class="ot">(</span>α ∙ β<span class="ot">)</span> == x <span class="ot">→</span> β == <span class="ot">(</span>α ⁻¹<span class="ot">)</span>
    uniqueʳ-⁻¹ <span class="ot">=</span> assoc+id+invˡ⇒invʳ-unique assoc identity inverseˡ</code></pre></div>
<h2 id="abelian-group">Abelian Group</h2>
<p>An Abelian group, named after Niels Henrik Abel, isb a group and requires its operation to also be commutative.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">record</span> IsAbelianGroup <span class="ot">(</span>∙ <span class="ot">:</span> ★ A<span class="ot">)</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">(</span>⁻¹ <span class="ot">:</span> ♠ A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    <span class="kw">field</span>
      isGroup <span class="ot">:</span> IsGroup ∙ x ⁻¹
      comm    <span class="ot">:</span> Commutative ∙

    <span class="kw">open</span> IsGroup isGroup <span class="kw">public</span></code></pre></div>
<hr />
<p><a href="./Algebra.structures.html">Groups and family 2</a></p>
</body>
</html>
