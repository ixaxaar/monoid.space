<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/groups</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.order.html">Previous</a> <a
href="Algebra.groups2.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#groups-and-family">Groups and family</a>
<ul>
<li><a href="#magma">Magma</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#commutative-monoid">Commutative Monoid</a></li>
<li><a href="#group">Group</a></li>
<li><a href="#abelian-group">Abelian Group</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="groups-and-family">Groups and family</h1>
<pre class="agda"><code>open import Types.relations
open import Types.equality renaming (refl to ≡-refl)
open import Types.functions
open import Types.product
open import Algebra.sets

open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

module Algebra.groups {a ℓ} {A : Set a} (_==_ : Rel A ℓ) where

  open import Types.operations (_==_)</code></pre>
<p>Group-like objects form another family of objects probed in abstract algebra. They have a similar pattern of building
like ordered objects but are more complex. This family contains of a set of type <code>A</code> and a binary operation
<code>⋅</code> defined on that set which satisfy a bunch of properties. As there are a large number of properties to
choose from, one can end up with a large number of families, however here we describe only a few that generally
matter.</p>
<table>
<thead>
<tr>
<th>Object ↓ Laws →</th>
<th>Totality</th>
<th>Associativity</th>
<th>Identity</th>
<th>Invertibility</th>
<th>Commutativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Magma</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Semigroupoid</td>
<td></td>
<td>★</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Small Category</td>
<td></td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Quasigroup</td>
<td>★</td>
<td></td>
<td></td>
<td>★</td>
<td></td>
</tr>
<tr>
<td>Loop</td>
<td>★</td>
<td></td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr>
<td>Semigroup</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Inverse Semigroup</td>
<td>★</td>
<td>★</td>
<td></td>
<td>★</td>
<td></td>
</tr>
<tr>
<td>Groupoid</td>
<td></td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr>
<td>Monoid</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Group</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td></td>
</tr>
<tr>
<td>Abelian group</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
<td>★</td>
</tr>
</tbody>
</table>
<p>Note that we implement only the packaged version of laws here, the actual object types we define in the next section
<a href="./Algebra.groups2.html">Groups and family 2</a>, this is because we cannot have two high level modules per agda
file.</p>
<figure>
<img src="/artwork/algebra_structure.png" alt="Figure 1: Algebraic structures" />
<figcaption aria-hidden="true">Figure 1: Algebraic structures</figcaption>
</figure>
<p>As we see above, semigroupoid is a generalization of the semigroup, group is a stricter form of a monoid or all
groups are also monoids etc. Semigroupoids, Small Categories and Groupoids form what is called as partial abstract
algebra such that they don’t require the totality property which thus allows their operations to be partial
functions.</p>
<h2 id="magma">Magma</h2>
<p>A magma is a set of objects with a closed binary operation defined on them. It is one of the simplest objects in
abstract algebra.</p>
<p>A magma is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span>, represented by a setoid</li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
</ol>
<pre class="agda"><code>  record IsMagma (∙ : ★ A) : Set (a ⊔ ℓ) where
    field
      ∙-cong        : Congruent₂ ∙
      isEquivalence : IsEquivalence _==_

    open IsEquivalence isEquivalence public

    setoid : Setoid a ℓ
    setoid = record { isEquivalence = isEquivalence }

    -- satisfies congruence with underlying equivalence
    ∙-congˡ : LeftCongruent ∙
    ∙-congˡ y==z = ∙-cong y==z rfl

    ∙-congʳ : RightCongruent ∙
    ∙-congʳ y==z = ∙-cong rfl y==z</code></pre>
<p>Magmas are a nice start but are yet too general to be useful. Lets add more structure.</p>
<h2 id="semigroup">Semigroup</h2>
<p>A semigroup is a structure where the operation is associative.</p>
<p>A semigroup is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
</ol>
<pre class="agda"><code>  record IsSemigroup (∙ : ★ A) : Set (a ⊔ ℓ) where
    field
      isMagma : IsMagma ∙
      assoc   : Associative ∙

    open IsMagma isMagma public</code></pre>
<p>Semigroups are any data structure which support an addition operation but does not have a unit element.</p>
<h2 id="monoid">Monoid</h2>
<p>A monoid is a semigroup, with a special element called the identity element. Monoids and semigroups are perhaps of
most significance to programmers as these are widely used to model various types and operations on them. For example,
JSON objects and a <code>merge</code> operation on them form a monoid. Strings and string concatenation form monoids
too.</p>
<p>Here are a few examples of monoids:</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Operation</th>
<th>Identity</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>addition</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>subtraction</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>multiplication</td>
<td>1</td>
</tr>
<tr>
<td>float</td>
<td>addition</td>
<td>0.0</td>
</tr>
<tr>
<td>float</td>
<td>subtraction</td>
<td>0.0</td>
</tr>
<tr>
<td>float</td>
<td>multiplication</td>
<td>1.0</td>
</tr>
<tr>
<td>JSON</td>
<td>merge two JSONs</td>
<td><code>{}</code></td>
</tr>
<tr>
<td>JSON</td>
<td>create / delete / modify a key-value pair</td>
<td><code>{}</code></td>
</tr>
<tr>
<td>JSON</td>
<td><code>λ : JSON&lt;A, B&gt;, JSON&lt;A, B&gt; → JSON&lt;A, B&gt;</code></td>
<td><code>{}</code></td>
</tr>
<tr>
<td>string</td>
<td>concatenation</td>
<td><code>''</code></td>
</tr>
<tr>
<td>List / Array</td>
<td>concatenation</td>
<td><code>[]</code></td>
</tr>
</tbody>
</table>
<p>Monoidal operations (<code>∙ : A × A → A</code>) take two elements and “reduce” or “combine” them into one. In other
words they can be used to model types that can be aggregated arbitrarily, as one could take pairs of objects from a
monoid and combine them with the monoidal operation <code>∙ : A × A → A</code>. This combination is independent of
whether it is done in synchronous, concuirrent or in parallel on a computer.</p>
<p>A monoid is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
<li><code>∙</code> has an identity, i.e. <code>∃ i ∈ A, i ∙ i = i</code></li>
</ol>
<pre class="agda"><code>  record IsMonoid (∙ : ★ A) (x : A) : Set (a ⊔ ℓ) where
    field
      isSemigroup : IsSemigroup ∙
      identity    : Identity x ∙

    open IsSemigroup isSemigroup public

    -- utils
    identityˡ : LeftIdentity x ∙
    identityˡ = fst identity

    identityʳ : RightIdentity x ∙
    identityʳ = snd identity</code></pre>
<h2 id="commutative-monoid">Commutative Monoid</h2>
<p>A commutative monoid is a monoid with its operation required to be commutative.</p>
<p>A commutative monoid is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
<li><code>∙</code> has an identity, i.e. <code>∃ i ∈ A, i ∙ i = i</code></li>
<li><code>∙</code> is commutative, i.e. <code>x ∙ y = y ∙ x</code></li>
</ol>
<pre class="agda"><code>  record IsCommutativeMonoid (∙ : ★ A) (x : A) : Set (a ⊔ ℓ) where
    field
      isMonoid : IsMonoid ∙ x
      comm        : Commutative ∙

    open IsMonoid isMonoid public</code></pre>
<h2 id="group">Group</h2>
<p>A group is a monoid with the additional requirement of the binary operation to have an inverse operation for every
pair of elements of the group. A group is another widely-used structure.</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Used to model</th>
</tr>
</thead>
<tbody>
<tr>
<td>Physics</td>
<td>Symmetry in Noether’s theorem</td>
</tr>
<tr>
<td>Physics</td>
<td>Gauge theories (quantum electrodynamics, quantum field theory)</td>
</tr>
<tr>
<td>Physics</td>
<td>Gauge formulation of general relativity</td>
</tr>
<tr>
<td>Physics</td>
<td>M-brane theory (and other string theories)</td>
</tr>
<tr>
<td>Chemistry</td>
<td>Classification of crystal structure</td>
</tr>
<tr>
<td>Chemistry</td>
<td>Symmetries of molecules</td>
</tr>
<tr>
<td>Cryptography</td>
<td>ECDSA (Elliptic Curve Digital Signature Algorithm) signatures</td>
</tr>
</tbody>
</table>
<p>A group is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
<li><code>∙</code> has an identity, i.e. <code>∃ i ∈ A, i ∙ i = i</code></li>
<li>every object <code>x</code> has an inverse <code>x⁻¹</code>, such that <code>((x ⁻¹) ∙ x) == i</code></li>
</ol>
<pre class="agda"><code>  record IsGroup (_∙_ : ★ A) (x : A) (_⁻¹ : ♠ A) : Set (a ⊔ ℓ) where
    field
      isMonoid  : IsMonoid _∙_ x
      inverse   : Inverse x _⁻¹ _∙_
      ⁻¹-cong   : Congruent₁ _⁻¹

    open IsMonoid isMonoid public

    infixl 7 _-_
    _-_ : ★ A
    x - y = x ∙ (y ⁻¹)

    inverseˡ : LeftInverse x _⁻¹ _∙_
    inverseˡ = fst inverse

    inverseʳ : RightInverse x _⁻¹ _∙_
    inverseʳ = snd inverse

    open import Types.equational2
    open withCongruence _==_ _∙_ _⁻¹ rfl trans sym ∙-cong x public

    -- uniqueness of the inverses
    uniqueˡ-⁻¹ : ∀ α β → (α ∙ β) == x → α == (β ⁻¹)
    uniqueˡ-⁻¹ = assoc+id+invʳ⇒invˡ-unique assoc identity inverseʳ

    uniqueʳ-⁻¹ : ∀ α β → (α ∙ β) == x → β == (α ⁻¹)
    uniqueʳ-⁻¹ = assoc+id+invˡ⇒invʳ-unique assoc identity inverseˡ</code></pre>
<h2 id="abelian-group">Abelian Group</h2>
<p>An Abelian group, named after Niels Henrik Abel, is a group and requires its operation to also be commutative.</p>
<p>An abelian group is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is closed, i.e. <code>∀ x y ∈ 𝔽, (x ∙ y) ∈ 𝔽</code> or <code>∙ : 𝔽 × 𝔽 → 𝔽</code></li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
<li><code>∙</code> has an identity, i.e. <code>∃ i ∈ A, i ∙ i = i</code></li>
<li><code>∙</code> is commutative, i.e. <code>x ∙ y = y ∙ x</code></li>
<li>every object <code>x</code> has an inverse <code>x⁻¹</code>, such that <code>((x ⁻¹) ∙ x) == i</code></li>
</ol>
<pre class="agda"><code>  record IsAbelianGroup (∙ : ★ A) (x : A) (⁻¹ : ♠ A) : Set (a ⊔ ℓ) where
    field
      isGroup : IsGroup ∙ x ⁻¹
      comm    : Commutative ∙

    open IsGroup isGroup public

    isCommutativeMonoid : IsCommutativeMonoid ∙ x
    isCommutativeMonoid = record
      { isMonoid = isMonoid
      ; comm = comm
      }</code></pre>
<hr />
<p><a href="./Algebra.groups2.html">Groups and family 2</a></p>
</body>
</html>
