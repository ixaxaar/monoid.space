<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Category/naturalTransformation</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Category.functors.html">Previous</a> <a
href="Category.yonedaLemma.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#natural-transformations">Natural Transformations</a>
<ul>
<li><a href="#commutative-diagrams">Commutative Diagrams</a></li>
<li><a href="#composition">Composition</a></li>
<li><a href="#functor-categories">Functor Categories</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="natural-transformations">Natural Transformations</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Category<span class="ot">.</span>naturalTransformation <span class="kw">where</span></span></code></pre></div>
<h2 id="commutative-diagrams">Commutative Diagrams</h2>
<p>Commutative diagrams are a great tool widely used in category to pictorially depict constraints rather than using
mathematical equations. These diagrams are directed graphs with each node representing mathematical objects and the
arrows between them represent morphisms.</p>
<p>A commutative diagram often consists of three parts:</p>
<ul>
<li>objects (also known as vertices)</li>
<li>morphisms (also known as arrows or edges)</li>
<li>paths or composites (that compose these morphisms)</li>
</ul>
<p>A diagram is said to be commutative (or to commute) when if any two paths that connect the same two objects (no
matter how many hops each path may have) arrive at the same result - it does not matter which path one takes to arrive
at the end.</p>
<p>##Ô∏è Natural Transformations</p>
<p>Natural transformations are structure preserving maps between functors. Just as a functor is a morphism between
categories, a natural transformation is a morphism between two functors. Since it is at a higher level than functors, it
can also be called a 2-morphism.</p>
<figure>
<img src="/artwork/natural_transformation.png" alt="Figure 1: Natural Transformation" />
<figcaption aria-hidden="true">Figure 1: Natural Transformation</figcaption>
</figure>
<p>Given categories ‚ÑÇ and ùîª and functors <span class="math inline">\(F, G : ‚ÑÇ ‚Üí ùîª\)</span> and for some <span
class="math inline">\(f : x ‚Üí y\)</span>, a natural transformation <span class="math inline">\(Œ± : F ‚Üí G\)</span>
ensures the following diagram is satisfied (the following diagram ‚Äúcommutes‚Äù):</p>
<figure>
<img src="/artwork/natural_transformation_diagram.png" alt="Figure 2: Natural Transformation Commutative Diagram" />
<figcaption aria-hidden="true">Figure 2: Natural Transformation Commutative Diagram</figcaption>
</figure>
<h2 id="composition">Composition</h2>
<p>Natural transformations can either be composed horizontally or vertically:</p>
<figure>
<img src="/artwork/natural_transformation_composition.png" alt="Figure 3: Horizontal Composition" />
<figcaption aria-hidden="true">Figure 3: Horizontal Composition</figcaption>
</figure>
<figure>
<img src="/artwork/natural_transformation_composition_vertical.png" alt="Figure 4: Vertical Composition" />
<figcaption aria-hidden="true">Figure 4: Vertical Composition</figcaption>
</figure>
<p>Both kinds of composition allows for the associativity law and identity natural transformations.</p>
<h2 id="functor-categories">Functor Categories</h2>
<p>As we have seen above, composition of natural transformations follows all the laws that morphisms follow in a
category. We can take advantage of that fact and define a category of functors:</p>
<p>Given two categories ‚ÑÇ and ùîª, we can define a category of functors with: - Functors <span class="math inline">\(F_i :
‚ÑÇ ‚Üí ùîª\)</span> as objects - Natural transformations <span class="math inline">\(Œ∑ : F_i ‚Üí F_j\)</span> as morphisms</p>
<p>The natural transformations between ‚ÑÇ and ùîª which are isomorphisms are also called Natural Isomorphisms.</p>
<p>The above definition of functor categories take into account only vertical compositions. We can also define a more
general kind of functor categories, also called a 2-category:</p>
<p>Given a bunch of categories <span class="math inline">\(ùïî_i\)</span>, we can define a 2-category with: - categories
<span class="math inline">\(ùïî_i\)</span> as objects - Functors between <span class="math inline">\(ùïî_i\)</span> as
morphisms: <span class="math inline">\(F_{ij} : ùïî_i ‚Üí ùïî_j\)</span> - Natural transformations between functors as
2-morphisms: <span class="math inline">\(Œ∑ : F_{ij} ‚Üí F&#39;_{ij}\)</span> and <span class="math inline">\(Œ≥ : F_{ij} ‚Üí
G_{jk}\)</span></p>
<hr />
<p><a href="./Category.yoneda.html">Yoneda Lemma</a></p>
</body>
</html>
