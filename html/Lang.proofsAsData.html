<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#proofs-as-data">Proofs as data</a></li>
<li><a href="#order">Order</a></li>
<li><a href="#odd-or-even">Odd or Even</a></li>
<li><a href="#equality-of-natural-numbers">Equality of natural numbers</a></li>
<li><a href="#belongs-to">Belongs to</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="proofs-as-data">Proofs as data</h1>
<p>In type theory, mathematical proofs take a different course than the ones we’re generally familiar with. Since in type theory everything, including proofs themselves, are types, the correctness of a proof translates to the ability to create an object of that proof’s type. In simpler terms, if one claims a proposition, one has to show the proposition (which is a type) is valid. A type can be shown to be valid if one can construct an object of that type. Thus, in order to prove something, we need to create an object having the type of the proposition.</p>
<p>Propositions can be defined in a recursive way such that termination of computation proves the correctness of the proof. We recursively dismantle the input until the trivial case is left which completes the recursion process and our proof is done. This also implies that in cases where termination is not reached, one can say that the proof does not apply to, or, is invalid for such inputs.</p>
<p>Usually, a proof consists of: - trivial cases, serving as termination markers - recursive pattern matchers, for (de) constructing the proof from (to) the trivial cases</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> Lang<span class="ot">.</span>proofsAsData <span class="kw">where</span>

<span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures</code></pre></div>
<h2 id="order">Order</h2>
<p>For example, the <code>&lt;=</code> operator can be defined as consisting of two constructors:</p>
<ul>
<li>an identity constructor <code>ltz</code> which compares any natural number with <code>zero</code></li>
<li>a successive pattern matcher <code>lz</code> which tries to reduce comparison of <code>x &lt;= y</code>, to <code>x-1 &lt;= y-1</code>:</li>
</ul>
<p>After applying <code>lz</code> sufficient number of times, if we end up at <code>0 &lt;= x</code> where <code>ltz</code> is invoked, computation terminates and our theorem is proved.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>&lt;=<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  ltz <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> zero &lt;= n
  lt <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> m &lt;= n <span class="ot">→</span> <span class="ot">(</span>succ m<span class="ot">)</span> &lt;= <span class="ot">(</span>succ n<span class="ot">)</span>

<span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>&lt;=<span class="ot">_</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">idLess₁ <span class="ot">:</span> one &lt;= ten
idLess₁ <span class="ot">=</span> lt ltz

idLess₂ <span class="ot">:</span> two &lt;= seven
idLess₂ <span class="ot">=</span> lt <span class="ot">(</span>lt ltz<span class="ot">)</span>

idLess₃ <span class="ot">:</span> three &lt;= nine
idLess₃ <span class="ot">=</span> lt <span class="ot">(</span>lt <span class="ot">(</span>lt ltz<span class="ot">))</span></code></pre></div>
<p>If we try to compile something that is not true, the compiler will throw an error:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">idLess&#39; <span class="fu">:</span> ten <span class="fu">&lt;=</span> three
idLess&#39; <span class="fu">=</span> lt lt lt lt lt lt lt lt lt ltz</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">proofsAsData.lagda.md:<span class="dv">68</span>,<span class="dv">14</span><span class="op">-</span><span class="dv">16</span>
(_m_30 <span class="op">&lt;=</span> _n_31 → succ _m_30 <span class="op">&lt;=</span> succ _n_31) <span class="op">!=&lt;</span> (nine <span class="op">&lt;=</span> two) of
<span class="bu">type</span> Set</code></pre></div>
<h2 id="odd-or-even">Odd or Even</h2>
<p>The odd or even proofs can be defined as in the previous proof. Here we successively decrement <code>n</code> till we:</p>
<ul>
<li>reach <code>even₀</code> to prove <code>n</code> is even</li>
<li>reach <code>odd₀</code> to prove <code>n</code> is odd</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Even <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span>
<span class="kw">data</span> Odd <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span>

<span class="kw">data</span> Even <span class="kw">where</span>
  zeroIsEven <span class="ot">:</span> Even zero
  succ <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Even n <span class="ot">→</span> Even <span class="ot">(</span>succ <span class="ot">(</span>succ n<span class="ot">))</span>

<span class="kw">data</span> Odd <span class="kw">where</span>
  oneIsOdd <span class="ot">:</span> Odd one
  succ <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Odd n <span class="ot">→</span> Odd <span class="ot">(</span>succ <span class="ot">(</span>succ n<span class="ot">))</span></code></pre></div>
<p>by which we could prove:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">twoisEven <span class="ot">:</span> Even two
twoisEven <span class="ot">=</span> succ zeroIsEven

isFourEven <span class="ot">:</span> Even four
isFourEven <span class="ot">=</span> succ <span class="ot">(</span>succ zeroIsEven<span class="ot">)</span>

isSevenOdd <span class="ot">:</span> Odd seven
isSevenOdd <span class="ot">=</span> succ <span class="ot">(</span>succ <span class="ot">(</span>succ oneIsOdd<span class="ot">))</span></code></pre></div>
<h2 id="equality-of-natural-numbers">Equality of natural numbers</h2>
<p>Equality of natural numbers can be proven by successively comparing decrements of them, till we reach <code>0 = 0</code>. Else the computation never terminates:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  eq₀ <span class="ot">:</span> zero ≡ zero
  eq <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>succ n<span class="ot">)</span> ≡ <span class="ot">(</span>succ m<span class="ot">)</span></code></pre></div>
<p>Similar for not equals:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>≠<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  neq₀ <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> n ≠ zero
  neq₁ <span class="ot">:</span> <span class="ot">∀</span> m <span class="ot">→</span> zero ≠ m
  neq <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span> n m <span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>succ n<span class="ot">)</span> ≠ <span class="ot">(</span>succ m<span class="ot">)</span></code></pre></div>
<h2 id="belongs-to">Belongs to</h2>
<p>To prove that a particular element of type <code>A</code> belongs to a list <code>List'</code> of type <code>A</code>, we require:</p>
<ul>
<li>a reflexive constructor: <code>x</code> is always in a list containing <code>x</code> and a bunch of other elements <code>xs</code></li>
<li>a recursive pattern matcher which reduces <code>x ∈ list</code> to <code>x ∈ y + list₁</code>, which either reduces to</li>
<li><code>x ∈ x + list₁</code> which terminates the computation or</li>
<li><code>x ∈ list₁</code></li>
</ul>
<p>where <code>list₁</code> is <code>list</code> without <code>y</code>.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>∈<span class="ot">_</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> List A <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  refl <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">→</span> x ∈ <span class="ot">(</span>x :: xs<span class="ot">)</span>
  succ∈ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>y xs<span class="ot">}</span> <span class="ot">→</span> x ∈ xs <span class="ot">→</span> x ∈ <span class="ot">(</span>y :: xs<span class="ot">)</span>

<span class="kw">infixr</span> <span class="dv">4</span> <span class="ot">_</span>∈<span class="ot">_</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">theList <span class="ot">:</span> List ℕ
theList <span class="ot">=</span> one :: two :: four :: seven :: three :: []

threeIsInList <span class="ot">:</span> three ∈ theList
threeIsInList <span class="ot">=</span> succ∈ <span class="ot">(</span>succ∈ <span class="ot">(</span>succ∈ <span class="ot">(</span>succ∈ refl<span class="ot">)))</span></code></pre></div>
<hr />
<p><a href="./Lang.syntaxQuirks.html">Quirks of Syntax</a></p>
</body>
</html>
