<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/groups2</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.groups.html">Previous</a> <a
href="Algebra.morphisms.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#groups-and-family-2">Groups and family 2</a>
<ul>
<li><a href="#magma">Magma</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#commutative-monoid">Commutative Monoid</a></li>
<li><a href="#group">Group</a></li>
<li><a href="#abelian-group">Abelian Group</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="groups-and-family-2">Groups and family 2</h1>
<p>Here we define the objects based on the conditions defined in the previous section. It might be helpful here to think
of <code>Data</code> fields as various common datatypes as used in computer sciences, and the objects as the structure
defined on operations of that datatype.</p>
<p>We are bound to write this code in a new file as we are using a different module without the pre-supplied
<code>_==_</code> and <code>A : Set a</code>.</p>
<pre class="agda"><code>module Algebra.groups2 where

open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.relations
open import Types.equality
open import Algebra.groups</code></pre>
<p>We recall operations again here:</p>
<pre class="agda"><code>★_ : ∀ {a} → Set a → Set a
★ A = A → A → A

♠_ : ∀ {a} → Set a → Set a
♠ A = A → A</code></pre>
<h2 id="magma">Magma</h2>
<pre class="agda"><code>record Magma a ℓ : Set (lsuc (a ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _==_
  field
    Data      : Set a
    _==_      : Rel Data ℓ
    _∙_       : ★ Data
    isMagma   : IsMagma _==_ _∙_

  open IsMagma isMagma public</code></pre>
<h2 id="semigroup">Semigroup</h2>
<pre class="agda"><code>record Semigroup c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _==_
  field
    Data        : Set c
    _==_        : Rel Data ℓ
    _∙_         : ★ Data
    isSemigroup : IsSemigroup _==_ _∙_

  open IsSemigroup isSemigroup public

  magma : Magma c ℓ
  magma = record { isMagma = isMagma }</code></pre>
<h2 id="monoid">Monoid</h2>
<pre class="agda"><code>record Monoid c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _==_
  field
    Data     : Set c
    _==_      : Rel Data ℓ
    _∙_      : ★ Data
    ε        : Data
    isMonoid : IsMonoid _==_ _∙_ ε

  open IsMonoid isMonoid public

  semigroup : Semigroup c ℓ
  semigroup = record { isSemigroup = isSemigroup }

  magma : Magma c ℓ
  magma = record { isMagma = isMagma }</code></pre>
<h2 id="commutative-monoid">Commutative Monoid</h2>
<pre class="agda"><code>record CommutativeMonoid c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _∙_
  infix  4 _==_
  field
    Data                : Set c
    _==_                 : Rel Data ℓ
    _∙_                 : ★ Data
    ε                   : Data
    isCommutativeMonoid : IsCommutativeMonoid _==_ _∙_ ε

  open IsCommutativeMonoid isCommutativeMonoid public

  monoid : Monoid c ℓ
  monoid = record { isMonoid = isMonoid }

  semigroup : Semigroup c ℓ
  semigroup = record { isSemigroup = isSemigroup }

  magma : Magma c ℓ
  magma = record { isMagma = isMagma }</code></pre>
<h2 id="group">Group</h2>
<pre class="agda"><code>record Group c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infix  8 _⁻¹
  infixl 7 _∙_
  infix  4 _==_
  field
    Data    : Set c
    _==_    : Rel Data ℓ
    _∙_     : ★ Data
    ε       : Data
    _⁻¹     : ♠ Data
    isGroup : IsGroup _==_ _∙_ ε _⁻¹

  open IsGroup isGroup public

  monoid : Monoid _ _
  monoid = record { isMonoid = isMonoid }

  semigroup : Semigroup c ℓ
  semigroup = record { isSemigroup = isSemigroup }

  magma : Magma c ℓ
  magma = record { isMagma = isMagma }</code></pre>
<h2 id="abelian-group">Abelian Group</h2>
<pre class="agda"><code>open import Algebra.groups using (IsAbelianGroup)

record AbelianGroup c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infix  8 _⁻¹
  infixl 7 _∙_
  infix  4 _==_
  field
    Data           : Set c
    _==_            : Rel Data ℓ
    _∙_            : ★ Data
    ε              : Data
    _⁻¹            : ♠ Data
    isAbelianGroup : IsAbelianGroup _==_ _∙_ ε _⁻¹

  open IsAbelianGroup isAbelianGroup public

  group : Group c ℓ
  group = record { isGroup = isGroup }

  monoid : Monoid _ _
  monoid = record { isMonoid = isMonoid }

  semigroup : Semigroup c ℓ
  semigroup = record { isSemigroup = isSemigroup }

  magma : Magma c ℓ
  magma = record { isMagma = isMagma }</code></pre>
<hr />
<p><a href="./Algebra.morphisms.html">Group Morphisms</a></p>
</body>
</html>
