<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#universes-and-families">Universes and families</a></li>
<li><a href="#sets">Sets</a></li>
<li><a href="#universe-polymorphism">Universe Polymorphism</a></li>
<li><a href="#machinery-on-types">Machinery on Types</a></li>
<li><a href="#type-of">Type of</a></li>
<li><a href="#equality-of-types">Equality of types</a></li>
<li><a href="#identity-type">Identity type</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="universes-and-families">Universes and families</h1>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="pp">{-# OPTIONS --without-K #-}</span>

<span class="kw">module</span> Types<span class="ot">.</span>universe <span class="kw">where</span>

<span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures <span class="kw">using</span> <span class="ot">(</span>
  Bool<span class="ot">;</span> true<span class="ot">;</span> false<span class="ot">;</span>
  ⊥<span class="ot">;</span> ⊤<span class="ot">;</span> ℕ<span class="ot">;</span> List<span class="ot">;</span>
  zero<span class="ot">;</span> one<span class="ot">)</span>

<span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">renaming</span> <span class="ot">(</span>Level <span class="kw">to</span> AgdaLevel<span class="ot">;</span> lzero <span class="kw">to</span> alzero<span class="ot">;</span> lsuc <span class="kw">to</span> alsuc<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_</span> <span class="kw">to</span> <span class="ot">_</span>⊔⊔<span class="ot">_)</span></code></pre></div>
<p>We first define the universe, or type of all types. The type of all types is a <code>Set</code> in agda. The problem of paradoxes resulting from infinite sets and set of all sets can be avoided by constructing the type of all types as “universes” in a heirarchically cumulative way.</p>
<p>A universe is a set of types. Now, when we take our universe to be a set of types, there comes a problem of universe of all possible types, and we end up with Russel’s Paradox. To avoid this, we say that our universe is constructed heirarchically, with an index <code>i</code> such that universe <code>Uᵢ</code> ∈ Uᵢ₊₁ and so on.</p>
<p><br /><span class="math display"><em>U</em><sub>0</sub> ∈ <em>U</em><sub>1</sub> ∈ <em>U</em>_2 ∈ ... ∈ <em>U</em><sub><em>i</em></sub> ∈ <em>U</em><sub><em>i</em> + 1</sub> ∈ ... ∈ <em>U</em><sub>∞</sub></span><br /></p>
<p>Let us define the above index <code>i</code> of universe <code>Uᵢ</code>, called <code>Level</code> in agda’s standard library:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">infixl</span> <span class="dv">6</span> <span class="ot">_</span>⊔<span class="ot">_</span>

<span class="kw">postulate</span>
  Level <span class="ot">:</span> <span class="dt">Set</span></code></pre></div>
<p>We define it as a postulate so we dont have to provide an implementation yet. We continue to define some operations on it, i.e.:</p>
<ul>
<li><code>lzero</code>, the trivial level 0</li>
<li><code>lsuc</code> : successive iterator</li>
<li><code>_⊔_</code> : least upper bound, an operator that composes</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">postulate</span>
  lzero <span class="ot">:</span> Level
  lsuc  <span class="ot">:</span> <span class="ot">(</span>ℓ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> Level
  <span class="ot">_</span>⊔<span class="ot">_</span>   <span class="ot">:</span> <span class="ot">(</span>ℓ₁ ℓ₂ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> Level</code></pre></div>
<p>And finally, we define universe as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">record <span class="dt">Universe</span> u e <span class="fu">:</span> <span class="dt">Set</span> (lsuc (u ⊔ e)) <span class="kw">where</span>
  field
    <span class="co">-- Codes.</span>
    <span class="dt">U</span> <span class="fu">:</span> <span class="dt">Set</span> u

    <span class="co">-- Decoding function.</span>
    <span class="dt">El</span> <span class="fu">:</span> <span class="dt">U</span> <span class="ot">→</span> <span class="dt">Set</span> e</code></pre></div>
<div class="figure">
<img src="universes.png" alt="universes" />
<p class="caption">universes</p>
</div>
<p>A “family” of types varying over a given type are called, well “families of types”. An example of this would be the finite set, <a href="./dataStructures.html#finite-sequences">Fin</a> where every finite set has <code>n</code> elements where <code>n ∈ ℕ</code> and hence <code>Fin</code>, the creator of finite sets, is dependent on ℕ.</p>
<h1 id="sets">Sets</h1>
<p>Mathematical sets cannot be directly represented in Agda as they are subject to Russel’s Paradox. However, sets are defined in a way similar to universes.</p>
<ul>
<li>Generally a set is represented by <code>Set₁</code>.</li>
<li>There exist infinite other <code>Setᵢ</code> such that <code>Set₁ : Set₂ : Set₃ : ...</code></li>
</ul>
<p>In fact, These <code>Setᵢ</code>s are nothing but universes in Agda. Note that <code>Set₁</code> forms the large set, i.e. the set containing all sets.</p>
<p>In some implementations, universes are represented using a different keyword <code>Type</code> instead of <code>Set</code> in order to avoid confusing with them:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">Type <span class="ot">:</span> <span class="ot">(</span>i <span class="ot">:</span> AgdaLevel<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>alsuc i<span class="ot">)</span>
Type i <span class="ot">=</span> <span class="dt">Set</span> i

Type₀ <span class="ot">=</span> Type alzero
Type0 <span class="ot">=</span> Type alzero

Type₁ <span class="ot">=</span> Type <span class="ot">(</span>alsuc alzero<span class="ot">)</span>
Type1 <span class="ot">=</span> Type <span class="ot">(</span>alsuc alzero<span class="ot">)</span></code></pre></div>
<h1 id="universe-polymorphism">Universe Polymorphism</h1>
<p>Now, gieven that we have infinite heirarchical universes, we would have to define the same functions, data types and machinery for each universe level, which would be pretty tedious to say the least. However, we observe how our universes are defined and note that the level-based indexing system, that connects each successive universe, provides us with the mechanics to define objects for all universe levels <code>ℓ</code>:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">id <span class="ot">:</span> <span class="ot">{</span>ℓ <span class="ot">:</span> AgdaLevel<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> ℓ<span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> A
id x <span class="ot">=</span> x</code></pre></div>
<p>Here <code>id</code> represents a family of identity functions given a type <code>A</code> and its level <code>ℓ</code>.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>::<span class="ot">_</span>
<span class="kw">data</span> List₁ <span class="ot">{</span>ℓ <span class="ot">:</span> AgdaLevel<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> ℓ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>alsuc ℓ<span class="ot">)</span> <span class="kw">where</span>
  [] <span class="ot">:</span> List₁ A
  <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> List₁ A <span class="ot">→</span> List₁ A

someList <span class="ot">:</span> List₁ ℕ
someList <span class="ot">=</span> <span class="ot">(</span>one :: zero :: []<span class="ot">)</span>

sameList <span class="ot">:</span> List₁ ℕ
sameList <span class="ot">=</span> id someList</code></pre></div>
<h1 id="machinery-on-types">Machinery on Types</h1>
<h2 id="type-of">Type of</h2>
<p>We obviously need a means to check types:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">typeof <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> Type i<span class="ot">)</span> <span class="ot">(</span>u <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> A
typeof A u <span class="ot">=</span> u

<span class="kw">infix</span> <span class="dv">40</span> typeof
<span class="kw">syntax</span> typeof A u <span class="ot">=</span>  u :&gt; A</code></pre></div>
<h2 id="equality-of-types">Equality of types</h2>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">infix</span> <span class="dv">30</span> <span class="ot">_</span>==<span class="ot">_</span>
<span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> Type i<span class="ot">}</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> Type i <span class="kw">where</span>
  idp <span class="ot">:</span> a == a</code></pre></div>
<h2 id="identity-type">Identity type</h2>
<p>The equality of types is itself a type - the identity type:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">Path <span class="ot">=</span> <span class="ot">_</span>==<span class="ot">_</span></code></pre></div>
<hr />
<p><a href="./Types.relations.html">Relations</a></p>
</body>
</html>
