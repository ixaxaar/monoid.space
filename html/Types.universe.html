<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Types/universe</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Types.introduction.html">Previous</a> <a href="Types.relations.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#universes-and-families">Universes and families</a></li>
<li><a href="#sets">Sets</a></li>
<li><a href="#universe-polymorphism">Universe Polymorphism</a></li>
<li><a href="#machinery-on-types">Machinery on Types</a>
<ul>
<li><a href="#type-of">Type of</a></li>
<li><a href="#equality-of-types">Equality of types</a></li>
<li><a href="#identity-type">Identity type</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1"></a></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">module</span> Types<span class="ot">.</span>universe <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures <span class="kw">using</span> <span class="ot">(</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  Bool<span class="ot">;</span> true<span class="ot">;</span> false<span class="ot">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  ⊥<span class="ot">;</span> ⊤<span class="ot">;</span> ℕ<span class="ot">;</span> List<span class="ot">;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  zero<span class="ot">;</span> one<span class="ot">)</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">renaming</span> <span class="ot">(</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>  Level <span class="kw">to</span> AgdaLevel<span class="ot">;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  lzero <span class="kw">to</span> alzero<span class="ot">;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  lsuc <span class="kw">to</span> alsuc<span class="ot">;</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="ot">_</span>⊔<span class="ot">_</span> <span class="kw">to</span> <span class="ot">_</span>⊔⊔<span class="ot">_)</span></span></code></pre></div>
<h1 id="universes-and-families">Universes and families</h1>
<p>A universe can be thought of as a container for all of mathematics. There is no mathematics that is possible outside of universe. Now obviously this differs from our physical universe in a way that mathematics also describes purely conceptual stuff that need not have a physical manifestation, rather, in many ways our univrerse is a subset of the mathematical universe as it can be described by mathematical models.</p>
<p>For set theory, the universe can be thought as the set of all sets. For type theory, universes contain all types - hence essentially everything including objects, laws, theorems etc. The structure of the universe used in type theory are <a href="http://www.cs.rhul.ac.uk/home/zhaohui/universes.pdf">Russel-style and Taski-style universes</a> though we use the former as it is easier and sufficient for our purposes. There are other kinds of universes in mathematics, for example the <a href="https://ncatlab.org/nlab/show/Grothendieck+universe">Grothendieck universe</a>, <a href="https://en.wikipedia.org/wiki/Von_Neumann_universe">Von Neumann universe</a>.</p>
<p>The type of all types is called <code>Set</code> in agda. Now, in constructing this type of all types naively we encounter a bunch of paradoxes, namely <a href="https://ncatlab.org/nlab/show/Russell%27s+paradox">Russel’s Paradox</a>, <a href="https://ncatlab.org/nlab/show/Cantor%27s+paradox">Cantor’s Paradox</a>, <a href="https://ncatlab.org/nlab/show/Burali-Forti%27s+paradox">Girard’s Paradox</a> etc. These can be avoided by constructing the type of all types as “universes” in a heirarchically cumulative way. When we consider our universe to be the set of all types, we say that our universe is constructed heirarchically, with an index <code>i</code> such that universe <code>Uᵢ</code> ∈ Uᵢ₊₁ and so on.</p>
<p><span class="math display">\[
U_{0} \in U_{1} \in U\_{2} \in ... \in U_{i} \in U_{i+1}  \in ... \in U_{\infty}
\]</span></p>
<p>Let us define the above index <code>i</code> of universe <code>Uᵢ</code>, called <code>Level</code> in agda’s standard library:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">infixl</span> <span class="dv">6</span> <span class="ot">_</span>⊔<span class="ot">_</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">postulate</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  Level <span class="ot">:</span> <span class="dt">Set</span></span></code></pre></div>
<p>We define it as a postulate so we dont have to provide an implementation yet. We continue to define some operations on it, i.e.:</p>
<ul>
<li><code>lzero</code>, the trivial level 0</li>
<li><code>lsuc</code> : successive iterator</li>
<li><code>_⊔_</code> : least upper bound, an operator that composes</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">postulate</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  lzero <span class="ot">:</span> Level</span>
<span id="cb3-3"><a href="#cb3-3"></a>  lsuc  <span class="ot">:</span> <span class="ot">(</span>ℓ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> Level</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="ot">_</span>⊔<span class="ot">_</span>   <span class="ot">:</span> <span class="ot">(</span>ℓ₁ ℓ₂ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> Level</span></code></pre></div>
<p>And finally, we define universe as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>record <span class="dt">Universe</span> u e <span class="op">:</span> <span class="dt">Set</span> (lsuc (u ⊔ e)) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  field</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">-- Codes.</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="dt">U</span> <span class="op">:</span> <span class="dt">Set</span> u</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">-- Decoding function.</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="dt">El</span> <span class="op">:</span> <span class="dt">U</span> <span class="ot">→</span> <span class="dt">Set</span> e</span></code></pre></div>
<figure>
<img src="universes.png" alt="" /><figcaption>Figure 1: Universes</figcaption>
</figure>
<p>A “family” of types varying over a given type are called, well “families of types”. An example of this would be the finite set, <a href="./dataStructures.html#finite-sequences">Fin</a> where every finite set has <code>n</code> elements where <code>n ∈ ℕ</code> and hence <code>Fin</code>, the creator of finite sets, is dependent on ℕ.</p>
<h1 id="sets">Sets</h1>
<p>Mathematical sets cannot be directly represented in Agda as they are subject to Russel’s Paradox. However, sets are defined in a way similar to universes.</p>
<ul>
<li>Generally a set is represented by <code>Set₁</code>.</li>
<li>There exist infinite other <code>Setᵢ</code> such that <code>Set₁ : Set₂ : Set₃ : ...</code></li>
</ul>
<p>In fact, These <code>Setᵢ</code>s are nothing but universes in Agda. Note that <code>Set₁</code> forms the large set, i.e. the set containing all sets.</p>
<p>In some implementations, universes are represented using a different keyword <code>Type</code> instead of <code>Set</code> in order to avoid confusing with them:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1"></a>Type <span class="ot">:</span> <span class="ot">(</span>i <span class="ot">:</span> AgdaLevel<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>alsuc i<span class="ot">)</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>Type i <span class="ot">=</span> <span class="dt">Set</span> i</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>Type₀ <span class="ot">=</span> Type alzero</span>
<span id="cb5-5"><a href="#cb5-5"></a>Type0 <span class="ot">=</span> Type alzero</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>Type₁ <span class="ot">=</span> Type <span class="ot">(</span>alsuc alzero<span class="ot">)</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>Type1 <span class="ot">=</span> Type <span class="ot">(</span>alsuc alzero<span class="ot">)</span></span></code></pre></div>
<h1 id="universe-polymorphism">Universe Polymorphism</h1>
<p>Now, given that we have infinite heirarchical universes, we would have to define the same functions, data types and machinery for each universe level, which would be pretty tedious to say the least. However, we observe how our universes are defined and note that the level-based indexing system, that connects each successive universe, provides us with the mechanics to define objects for all universe levels <code>ℓ</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1"></a>id <span class="ot">:</span> <span class="ot">{</span>ℓ <span class="ot">:</span> AgdaLevel<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> ℓ<span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> A</span>
<span id="cb6-2"><a href="#cb6-2"></a>id x <span class="ot">=</span> x</span></code></pre></div>
<p>Here <code>id</code> represents a family of identity functions given a type <code>A</code> and its level <code>ℓ</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>::<span class="ot">_</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">data</span> List₁ <span class="ot">{</span>ℓ <span class="ot">:</span> AgdaLevel<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> ℓ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>alsuc ℓ<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  [] <span class="ot">:</span> List₁ A</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> List₁ A <span class="ot">→</span> List₁ A</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>someList <span class="ot">:</span> List₁ ℕ</span>
<span id="cb7-7"><a href="#cb7-7"></a>someList <span class="ot">=</span> <span class="ot">(</span>one :: zero :: []<span class="ot">)</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>sameList <span class="ot">:</span> List₁ ℕ</span>
<span id="cb7-10"><a href="#cb7-10"></a>sameList <span class="ot">=</span> id someList</span></code></pre></div>
<h1 id="machinery-on-types">Machinery on Types</h1>
<h2 id="type-of">Type of</h2>
<p>We obviously need a means to check types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1"></a>typeof <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> Type i<span class="ot">)</span> <span class="ot">(</span>u <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> A</span>
<span id="cb8-2"><a href="#cb8-2"></a>typeof A u <span class="ot">=</span> u</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">infix</span> <span class="dv">40</span> typeof</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">syntax</span> typeof A u <span class="ot">=</span>  u :&gt; A</span></code></pre></div>
<h2 id="equality-of-types">Equality of types</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">infix</span> <span class="dv">30</span> <span class="ot">_</span>==<span class="ot">_</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> Type i<span class="ot">}</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> Type i <span class="kw">where</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  idp <span class="ot">:</span> a == a</span></code></pre></div>
<h2 id="identity-type">Identity type</h2>
<p>The equality of types is itself a type - the identity type:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1"></a>Path <span class="ot">=</span> <span class="ot">_</span>==<span class="ot">_</span></span></code></pre></div>
<hr />
<p><a href="./Types.relations.html">Relations</a></p>
</body>
</html>
