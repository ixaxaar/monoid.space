<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#data-structures">Data Structures</a></li>
<li><a href="#data-keyword"><code>Data</code> keyword</a></li>
<li><a href="#trivial-types">Trivial types</a>
<ul>
<li><a href="#empty">Empty</a></li>
<li><a href="#singleton">Singleton</a></li>
</ul></li>
<li><a href="#boolean-type">Boolean type</a></li>
<li><a href="#natural-numbers">Natural numbers</a></li>
<li><a href="#binary-trees">Binary Trees</a></li>
<li><a href="#graph">Graph</a></li>
<li><a href="#list">List</a></li>
<li><a href="#finite-sequences">Finite sequences</a></li>
<li><a href="#indexed-sequences-or-vectors">Indexed sequences or Vectors</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="data-structures">Data Structures</h1>
<p>Here we look at how to define data structures in Agda.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> Lang<span class="ot">.</span>dataStructures <span class="kw">where</span></code></pre></div>
<p>Agda is an implementation of type theory, a branch of mathematics where everything is a <em>type</em>. Unlike programming languages where there is a clear distinction betwen (data)type and data, where <code>1</code> is data of type <code>int</code>. In Agda, <code>1</code> is a type itself and is of type say <code>ℕ</code> (natural numbers). There do remain quite a few similarities, for example, like some programming languages allow functions to be passed around as objects of type <code>A =&gt; B</code>, similarly, all functions are also types in type theory. This simplicity could get confusing at first and takes some time to get used to given the reader has been a programmer for a while.</p>
<p>Just remember: in type theory, <strong>EVERYTHING is a type</strong>.</p>
<h1 id="data-keyword"><code>Data</code> keyword</h1>
<p>As we probably know already, programming languages come bundled with some primitive data types like <code>int</code>, <code>float</code>, <code>string</code> etc and some that combine these primitive types into more complex structures, e.g. <code>map</code> can be used to construct say <code>map&lt;string, array&lt;string&gt;&gt;</code>.</p>
<p>Some languages also provide the mechanism to define new data types, sometimes by alias-ing a data type with a name like in scala:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> newData = Map[String, List[Float]]</code></pre></div>
<p>This is called <em>type aliasing</em>.</p>
<p>Some languages provide the facility to define new data types, like haskell does with the <code>data</code> keyword:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- this states that the type `Bool` can have two values False and True</span>
<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span></code></pre></div>
<p>A haskell datatype can also have constructors. For e.g. if we were to define a shape type which can either be a circle or a rectange:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Shape</span> <span class="fu">=</span> <span class="dt">Circle</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="fu">|</span> <span class="dt">Rectangle</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="dt">Float</span>

<span class="co">-- uses the Circle constructor to create an object of type Shape</span>
<span class="dt">Circle</span> <span class="fl">1.2</span> <span class="fl">12.1</span> <span class="fl">123.1</span>

<span class="co">-- uses the Rectange constructor to create an object of type Shape</span>
<span class="dt">Rectange</span> <span class="fl">1.2</span> <span class="fl">12.1</span> <span class="fl">123.1</span> <span class="fl">1234.5</span></code></pre></div>
<p>The <code>data</code> keyword works in a similar manner in Agda:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="co">-- lets assume SomeType1 and SomeType2 to be previously defined</span>
<span class="kw">module</span> <span class="ot">_</span> <span class="ot">{</span>SomeType1 SomeType2 <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="kw">where</span>

  <span class="kw">data</span> AgdaData <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    <span class="co">-- constructors, all return AgdaData</span>
    constructor1 <span class="ot">:</span> SomeType1 <span class="ot">→</span> AgdaData
    constructor2 <span class="ot">:</span> SomeType2 <span class="ot">→</span> AgdaData
    trivialConstructor <span class="ot">:</span> AgdaData
    etc <span class="ot">:</span> SomeType1 <span class="ot">→</span> SomeType2 <span class="ot">→</span> AgdaData</code></pre></div>
<h2 id="trivial-types">Trivial types</h2>
<h3 id="empty">Empty</h3>
<p>An empty object cannot be created cause it has no constructor. This is the most barebones of a <code>data</code> definition.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ⊥ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></code></pre></div>
<h3 id="singleton">Singleton</h3>
<p>A singleton is just a type containing only one object. Note that this is different from the singleton patterns prevalent in various languages like java.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ⊤ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  singleton <span class="ot">:</span> ⊤</code></pre></div>
<p>A singleton constructor <code>singleton</code> creates a single object of type <code>T</code>.</p>
<h2 id="boolean-type">Boolean type</h2>
<p>The boolean type has just two values:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Bool <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  true <span class="ot">:</span> Bool
  false <span class="ot">:</span> Bool</code></pre></div>
<h2 id="natural-numbers">Natural numbers</h2>
<p>All natural numbers can be created from <code>zero</code> and n successive numbers after <code>zero</code>. All we need to know are</p>
<ul>
<li>zero</li>
<li>how to increment a number</li>
</ul>
<p>and then, increment zero to infinity!</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="ot">:</span> ℕ
  succ <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</code></pre></div>
<p>Examples:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">one   <span class="ot">=</span> succ zero
two   <span class="ot">=</span> succ one
three <span class="ot">=</span> succ two
four  <span class="ot">=</span> succ three
five  <span class="ot">=</span> succ four
six   <span class="ot">=</span> succ five
seven <span class="ot">=</span> succ six
eight <span class="ot">=</span> succ seven
nine  <span class="ot">=</span> succ eight
ten   <span class="ot">=</span> succ nine</code></pre></div>
<p>and so on recursively.</p>
<h2 id="binary-trees">Binary Trees</h2>
<p>We define a generic complete binary tree using the following definition. Note that this merely creates an empty structure of a tree, the nodes or leaves contain no information in them:</p>
<div class="figure">
<img src="./bintree.png" alt="bintree" />
<p class="caption">bintree</p>
</div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> BinTree <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  leaf <span class="ot">:</span> BinTree
  node <span class="ot">:</span> BinTree <span class="ot">→</span> BinTree <span class="ot">→</span> BinTree</code></pre></div>
<p>Now let us augment the binary trees with leaves containing natural numbers in leaf nodes:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕBinTree <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  leaf <span class="ot">:</span> ℕ <span class="ot">→</span> ℕBinTree
  node <span class="ot">:</span> ℕBinTree <span class="ot">→</span> ℕBinTree <span class="ot">→</span> ℕBinTree</code></pre></div>
<p>Binary trees with each node and leaf containing a natural number:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕNodeBinTree <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  leaf <span class="ot">:</span> ℕ <span class="ot">→</span> ℕNodeBinTree
  node <span class="ot">:</span> ℕ <span class="ot">→</span> ℕNodeBinTree <span class="ot">→</span> ℕNodeBinTree <span class="ot">→</span> ℕNodeBinTree</code></pre></div>
<p>Binary trees with each node containing a natural number and each leaf contaning a boolean:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕMixedBinTree <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  leaf <span class="ot">:</span> Bool <span class="ot">→</span> ℕMixedBinTree
  node <span class="ot">:</span> ℕ <span class="ot">→</span> ℕMixedBinTree <span class="ot">→</span> ℕMixedBinTree <span class="ot">→</span> ℕMixedBinTree</code></pre></div>
<h2 id="graph">Graph</h2>
<div class="figure">
<img src="./graph.png" alt="graph" />
<p class="caption">graph</p>
</div>
<p>We define a graph with:</p>
<ul>
<li>edges containing a natural number</li>
<li>represented as an edge-list, i.e. a list of triples</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Vertex <span class="ot">:</span> <span class="dt">Set</span>
<span class="kw">data</span> EdgeTriple <span class="ot">:</span> <span class="dt">Set</span>
<span class="kw">data</span> Graph <span class="ot">:</span> <span class="dt">Set</span>

<span class="kw">data</span> Vertex <span class="kw">where</span>
  vertex <span class="ot">:</span> ℕ <span class="ot">→</span> Vertex

<span class="kw">data</span> EdgeTriple <span class="kw">where</span>
  triple <span class="ot">:</span> Vertex <span class="ot">→</span> Vertex <span class="ot">→</span> EdgeTriple

<span class="kw">data</span> Graph <span class="kw">where</span>
  idGraph <span class="ot">:</span> EdgeTriple <span class="ot">→</span> Graph
  <span class="ot">_</span>+|+<span class="ot">_</span> <span class="ot">:</span> Graph <span class="ot">→</span> EdgeTriple <span class="ot">→</span> Graph

<span class="kw">infixl</span> <span class="dv">3</span> <span class="ot">_</span>+|+<span class="ot">_</span></code></pre></div>
<p>The <code>infixl</code> sets the precedence of the infix operator <code>+|+</code>. To indicate an operator operates in an infix way, the operator <code>op</code> is represented as <code>_op_</code>. Similarly, for an operator <code>x + y = z</code>, we represent them as <code>_+_=_</code>.</p>
<p>We can use the above definition to create a graph in the following way:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">graph <span class="ot">:</span> Graph
graph <span class="ot">=</span> idGraph <span class="ot">(</span>triple <span class="ot">(</span>vertex zero<span class="ot">)</span>   <span class="ot">(</span>vertex seven<span class="ot">))</span>     +|+
                triple  <span class="ot">(</span>vertex one<span class="ot">)</span>    <span class="ot">(</span>vertex three<span class="ot">)</span>      +|+
                triple  <span class="ot">(</span>vertex seven<span class="ot">)</span>  <span class="ot">(</span>vertex four<span class="ot">)</span>       +|+
                triple  <span class="ot">(</span>vertex nine<span class="ot">)</span>   <span class="ot">(</span>vertex <span class="ot">(</span>succ six<span class="ot">))</span></code></pre></div>
<h2 id="list">List</h2>
<div class="figure">
<img src="./list.png" alt="list" />
<p class="caption">list</p>
</div>
<p>A list containing objects of type <code>A</code> can be defined as an object which has:</p>
<ul>
<li>an identity element, i.e. an empty list <code>[]</code></li>
<li>a concat operator which successively creates bigger lists <code>::</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> List <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  [] <span class="ot">:</span> List A
  <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> List A <span class="ot">→</span> List A

<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>::<span class="ot">_</span></code></pre></div>
<p>and we create instances of lists as:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">bunch <span class="ot">:</span> List Bool
bunch <span class="ot">=</span> false :: false :: true :: false :: true :: []</code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> TypeOf <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  typeOf <span class="ot">:</span> List A <span class="ot">→</span> TypeOf A</code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">nat <span class="ot">:</span> TypeOf ℕ
nat <span class="ot">=</span> typeOf <span class="ot">(</span> one :: two :: ten :: [] <span class="ot">)</span></code></pre></div>
<h2 id="finite-sequences">Finite sequences</h2>
<p>The type class of a finite set, or merely an index, consists of:</p>
<ul>
<li>an identity element: create a finite set of size <code>n</code></li>
<li>a recursive creator: create finite sets successively</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Fin <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  id <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> Fin <span class="ot">(</span>succ n<span class="ot">)</span>
  succ <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin <span class="ot">(</span>succ n<span class="ot">)</span></code></pre></div>
<p>Creating a finite set of four elements:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">fourFin <span class="ot">:</span> Fin four
fourFin <span class="ot">=</span> succ three <span class="ot">(</span>succ two <span class="ot">(</span>succ one <span class="ot">(</span>id zero<span class="ot">)))</span></code></pre></div>
<h2 id="indexed-sequences-or-vectors">Indexed sequences or Vectors</h2>
<div class="figure">
<img src="./vector.png" alt="vectors" />
<p class="caption">vectors</p>
</div>
<p>We now define a finite sized indexed list, also called a vector <code>Vec</code>. The constructor consists of:</p>
<ul>
<li>An identity constructor, <code>[]</code> which constructs an empty vector</li>
<li>A successive constructor <code>cons</code> which appends successively builds a vector</li>
</ul>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Vec <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  [] <span class="ot">:</span> Vec A zero
  cons <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> A <span class="ot">→</span> Vec A n <span class="ot">→</span> Vec A <span class="ot">(</span>succ n<span class="ot">)</span></code></pre></div>
<p>Examples of vectors :</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">vec1 <span class="ot">:</span> Vec Bool one
vec1 <span class="ot">=</span> cons zero true []

vec2 <span class="ot">:</span> Vec Bool two
vec2 <span class="ot">=</span> cons one false vec1

vec3 <span class="ot">:</span> Vec Bool three
vec3 <span class="ot">=</span> cons two true vec2</code></pre></div>
<p>Note that each vector has its size encoded into it’s type. This is not to be confused with set theory based lists, where any two list of different number of elements have the same type.</p>
<p>For example in scala:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> x : List[Int] = List(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>)
<span class="kw">val</span> y : List[Int] = List(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">0</span>)</code></pre></div>
<p>both have the same type. However, in pure type theory they are considered different types as type theory considers the size of the list as type information.</p>
<p>Example, a bool-indexed vector such that only one type can be stored at the same time:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ⟂ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>

<span class="kw">data</span> BoolVec<span class="ot">(</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Bool <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  id₁ <span class="ot">:</span> B <span class="ot">→</span> BoolVec A B false
  id₂ <span class="ot">:</span> A <span class="ot">→</span> BoolVec A B true

containsB <span class="ot">:</span> BoolVec ⟂ ℕ false
containsB <span class="ot">=</span> id₁ three

containsA <span class="ot">:</span> BoolVec ℕ ⟂ true
containsA <span class="ot">=</span> id₂ four</code></pre></div>
<hr />
<p><a href="./Lang.functions.html">Functions</a></p>
</body>
</html>
