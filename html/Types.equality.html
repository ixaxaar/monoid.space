<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Types/equality</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Types.relations.html">Previous</a> <a href="Types.operations.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#equalities">Equalities</a></li>
<li><a href="#definitional-equality">Definitional Equality</a></li>
<li><a href="#computational-equality">Computational Equality</a></li>
<li><a href="#propositional-equality">Propositional Equality</a>
<ul>
<li><a href="#symmetry">Symmetry</a></li>
<li><a href="#transitivity">Transitivity</a></li>
<li><a href="#congruence-functions-that-preserve-equality">Congruence: functions that preserve equality</a></li>
<li><a href="#substitution">Substitution</a></li>
</ul></li>
<li><a href="#relations-with-universe-polymorphism">Relations, with universe polymorphism</a>
<ul>
<li><a href="#equality">Equality</a></li>
<li><a href="#types-of-relations">Types of relations</a></li>
<li><a href="#nullary-relations">Nullary relations</a></li>
<li><a href="#unary-relations">Unary relations</a></li>
<li><a href="#binary-relations">Binary relations</a></li>
<li><a href="#properties-of-binary-relations">Properties of binary relations</a></li>
<li><a href="#properties-of-equality">Properties of equality</a></li>
</ul></li>
<li><a href="#setoids">Setoids</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="equalities">Equalities</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> Types<span class="ot">.</span>equality <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures <span class="kw">using</span> <span class="ot">(</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  Bool<span class="ot">;</span> true<span class="ot">;</span> false<span class="ot">;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  ⟂<span class="ot">;</span> ⊤<span class="ot">;</span> ℕ<span class="ot">;</span> List<span class="ot">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  one<span class="ot">;</span> two<span class="ot">;</span> three<span class="ot">;</span> four<span class="ot">;</span> five<span class="ot">;</span> six<span class="ot">;</span> seven<span class="ot">;</span> eight<span class="ot">;</span> nine<span class="ot">;</span> ten<span class="ot">;</span> zero<span class="ot">;</span> succ<span class="ot">;</span> <span class="ot">_</span>+<span class="ot">_;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="ot">_</span>::<span class="ot">_;</span> []<span class="ot">)</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">using</span> <span class="ot">(</span>Level<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_;</span> lsuc<span class="ot">;</span> lzero<span class="ot">)</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>functions <span class="kw">using</span> <span class="ot">(_</span>on<span class="ot">_;</span> flip<span class="ot">)</span></span></code></pre></div>
<p>Equality is perhaps one of the most richest but most naively understood concepts. Here we try to provide some structural analysis as to what equality really means in various contexts of mathematics. Equality is treated as a relation in type theory and can be classified broadly as of three kinds:</p>
<ul>
<li>Propositional equality</li>
<li>Computational equality</li>
<li>Definitional equality</li>
</ul>
<h1 id="definitional-equality">Definitional Equality</h1>
<p>Definitional equality is the most basic notion of equality which appeals to our notion of equality being the sameness of meaning (by definition). For example, <code>9</code> and <code>3 + 3</code> represent the same thing and hence are definitionally equal <code>9 ≡ 3²</code>. Similarly <code>two ≡ succ (succ zero)</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1"></a>defEqual₁ <span class="ot">:</span> ℕ</span>
<span id="cb2-2"><a href="#cb2-2"></a>defEqual₁ <span class="ot">=</span> seven</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>defEqual₂ <span class="ot">:</span> ℕ</span>
<span id="cb2-5"><a href="#cb2-5"></a>defEqual₂ <span class="ot">=</span> succ <span class="ot">(</span>succ five<span class="ot">)</span></span></code></pre></div>
<p>Here, <code>defEqual₁</code> and <code>defEqual₂</code> both are equal, with equality of the kind “definitional equality”.</p>
<h1 id="computational-equality">Computational Equality</h1>
<p>This kind of equality describes the sameness of types that are not directly equal but can be reduced to be equal. “Reduction” here implies mathematical reduction, referring to rewriting expressions into simpler forms. An example of such an equality is applying a function <span class="math display">\[(λ x.x+x)(2) ≡ 2 + 2\]</span> Expansions of recursors also falls under this kind of equality: <span class="math display">\[2 + 2 ≡ succ (succ zero) + succ (succ zero) ≡ succ (succ (succ (succ zero)))\]</span> Practically, computational equality is included into definitional equality and is also known as “Judgemental equality”.</p>
<h1 id="propositional-equality">Propositional Equality</h1>
<p>Definitional and computational equalities describe something intrinsic - a property that does not depend upon a proof. For example, <code>a + b ≡ b + a</code> cannot be proven to be definitionally equal unless the concrete values of <code>a</code> and <code>b</code> are known. However, if they’re natural numbers <code>a, b ∈ ℕ</code>, then the statement <code>a + b ≡ b + a</code> requires a proof to claim its truthfulness. Given <code>a, b ∈ ℕ</code>, we can prove that <code>a + b ≡ b + a</code> or in other words that there exists an identity of type <code>Id : a + b ≡ b + a</code> where <code>Id</code> is a proposition − exhibiting a term belonging to such a type is exhibiting (i.e. proving) such a propositional equality.</p>
<p>However, other notions of equalities can be defined that do require proofs. Consider for example natural language - when we say “all flowers are beautiful” the “all flowers” part of the sentence implies all flowers are equal in some way. Or, consider natural numbers <code>a + b = b + a ∀ a, b ∈ ℕ</code>. Here we would need to prove the symmetry of the <code>+</code> operator in order to prove the equality. Such equalities that require to be specified come under the umbrella of propositional equality. Propositional equality is a kind of equality which requires a proof, and hence the equality itself is also a type <code>∼</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>infix <span class="dv">4</span> _∼_</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">data</span> _∼_ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>}(a <span class="op">:</span> <span class="dt">A</span>) <span class="op">:</span> {<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  same <span class="op">:</span> a ∼ a</span></code></pre></div>
<p>Reflexivity is defined with the definition of <code>∼</code> by the keyword <code>same</code>, the others being:</p>
<h3 id="symmetry">Symmetry</h3>
<p>Symmetry is the property where binary a relation’s behavior does not depend upon its argument’s position (left or right):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>symmetry <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span>}{a <span class="op">:</span> <span class="dt">A</span>}{b <span class="op">:</span> <span class="dt">B</span>}</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">→</span> a ∼ b</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="ot">→</span> b ∼ a</span>
<span id="cb4-4"><a href="#cb4-4"></a>symmetry same <span class="ot">=</span> same</span></code></pre></div>
<h3 id="transitivity">Transitivity</h3>
<p>Transitivity is when a binary relation <code>_∼_</code> and <span class="math inline">\(x ∼ y and y ∼ z ⟹ x ∼ z\)</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>transitivity <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="dt">C</span>}{a <span class="op">:</span> <span class="dt">A</span>}{b <span class="op">:</span> <span class="dt">B</span>}{c <span class="op">:</span> <span class="dt">C</span>}</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ot">→</span> a ∼ b</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="ot">→</span> b ∼ c</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="ot">→</span> a ∼ c</span>
<span id="cb5-5"><a href="#cb5-5"></a>transitivity same p <span class="ot">=</span> p</span></code></pre></div>
<h3 id="congruence-functions-that-preserve-equality">Congruence: functions that preserve equality</h3>
<p>Functions that when applied to objects of a type, do not alter the operation of equality can be defined as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>congruence <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} (f <span class="op">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span>) {x y <span class="op">:</span> <span class="dt">A</span>}</span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="ot">→</span> x ∼ y</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="ot">→</span> f x ∼ f y</span>
<span id="cb6-4"><a href="#cb6-4"></a>congruence f same <span class="ot">=</span> same</span></code></pre></div>
<h3 id="substitution">Substitution</h3>
<p>If <code>a = b</code> and if <code>predicate a = true</code> ⟹ <code>predicate b = true</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>substitution <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} {x y <span class="op">:</span> <span class="dt">A</span>} (<span class="dt">Predicate</span> <span class="op">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="ot">→</span> x ∼ y</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="ot">→</span> <span class="dt">Predicate</span> x</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="ot">→</span> <span class="dt">Predicate</span> y</span>
<span id="cb7-5"><a href="#cb7-5"></a>substitution <span class="dt">Predicate</span> same p <span class="ot">=</span> p</span></code></pre></div>
<p>Any relation which satisfies the above properties of <code>reflexivity</code>, <code>transitivity</code> and <code>symmetry</code> can be considered an equivalence relation and hence can judge a propositional equality.</p>
<h1 id="relations-with-universe-polymorphism">Relations, with universe polymorphism</h1>
<p>We now present a more formal machinery for relations. We use <a href="Types.universe.html#universe-polymorphism">universe polymorphism</a> throughout to develop this machinery.</p>
<h3 id="equality">Equality</h3>
<p>We first re-define propositional equality within the framework of universe polymorphism:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≡<span class="ot">_</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  instance refl <span class="ot">:</span> x ≡ x</span></code></pre></div>
<h3 id="types-of-relations">Types of relations</h3>
<h3 id="nullary-relations">Nullary relations</h3>
<p>Nullary relations are functions that can take any object and return an empty set <code>∅</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1"></a>¬  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>ℓ<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="ot">→</span> <span class="dt">Set</span> ℓ</span>
<span id="cb9-2"><a href="#cb9-2"></a>¬ P <span class="ot">=</span> P <span class="ot">→</span> ⟂</span></code></pre></div>
<h3 id="unary-relations">Unary relations</h3>
<p>In logic, a predicate can essentially be defined as a function that returns a binary value - whether the proposition that the predicate represents is true or false. In type theory, however, we define predicate in a different way. A predicate for us is a function that exists (and hence, is true):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1"></a>Pred <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="ot">(</span>ℓ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ lsuc ℓ<span class="ot">)</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>Pred A ℓ <span class="ot">=</span> A <span class="ot">→</span> <span class="dt">Set</span> ℓ</span></code></pre></div>
<p>The empty (or false) predicate becomes:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1"></a>∅ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Pred A lzero</span>
<span id="cb11-2"><a href="#cb11-2"></a>∅ <span class="ot">=</span> <span class="ot">λ</span> <span class="ot">_</span> <span class="ot">→</span> ⟂</span></code></pre></div>
<p>The singleton predicate (constructor):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1"></a>is<span class="ot">_</span>sameAs <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>        <span class="ot">→</span> A</span>
<span id="cb12-3"><a href="#cb12-3"></a>        <span class="ot">→</span> Pred A a</span>
<span id="cb12-4"><a href="#cb12-4"></a>is x sameAs <span class="ot">=</span> x ≡<span class="ot">_</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1"></a>equal? <span class="ot">:</span> is six sameAs <span class="ot">(</span>succ five<span class="ot">)</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>equal? <span class="ot">=</span> refl</span></code></pre></div>
<h3 id="binary-relations">Binary relations</h3>
<p>A heterogeneous binary relation is defined as:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1"></a>REL <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="dt">Set</span> b <span class="ot">→</span> <span class="ot">(</span>ℓ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ b ⊔ lsuc ℓ<span class="ot">)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>REL A B ℓ <span class="ot">=</span> A <span class="ot">→</span> B <span class="ot">→</span> <span class="dt">Set</span> ℓ</span></code></pre></div>
<p>and a homogenous one as:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1"></a>Rel <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="ot">(</span>ℓ <span class="ot">:</span> Level<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ lsuc ℓ<span class="ot">)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>Rel A ℓ <span class="ot">=</span> REL A A ℓ</span></code></pre></div>
<h3 id="properties-of-binary-relations">Properties of binary relations</h3>
<p>In type theory, an implication $ A ⟹ B $ is just a function type $ f: A → B $, and if <code>f</code> exists, the implication does too. We define implication between two relations in agda as:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">_</span>⇒<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>        <span class="ot">→</span> REL A B ℓ₁</span>
<span id="cb16-3"><a href="#cb16-3"></a>        <span class="ot">→</span> REL A B ℓ₂</span>
<span id="cb16-4"><a href="#cb16-4"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>P ⇒ Q <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>i j<span class="ot">}</span> <span class="ot">→</span> P i j <span class="ot">→</span> Q i j</span></code></pre></div>
<p>A function <code>f : A → B</code> is invariant to two homogenous relations <code>Rel A ℓ₁</code> and <code>Rel B ℓ₂</code> if $ ∀ x, y ∈ A <sub>and</sub> f(x), f(y) ∈ B, f(Rel x y) ⟹ (Rel f(x) f(y)) $:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">_</span>=[<span class="ot">_</span>]⇒<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>          <span class="ot">→</span> Rel A ℓ₁</span>
<span id="cb17-3"><a href="#cb17-3"></a>          <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>          <span class="ot">→</span> Rel B ℓ₂</span>
<span id="cb17-5"><a href="#cb17-5"></a>          <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>P =[ f ]⇒ Q <span class="ot">=</span> P ⇒ <span class="ot">(</span>Q on f<span class="ot">)</span></span></code></pre></div>
<p>A function <code>f</code> preserves an underlying relation while operating on a datatype if:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">_</span>Preserves<span class="ot">_</span>⟶<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>        <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>        <span class="ot">→</span> Rel A ℓ₁</span>
<span id="cb18-4"><a href="#cb18-4"></a>        <span class="ot">→</span> Rel B ℓ₂</span>
<span id="cb18-5"><a href="#cb18-5"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>f Preserves P ⟶ Q <span class="ot">=</span> P =[ f ]⇒ Q</span></code></pre></div>
<p>Similarly, a binary operation <code>_+_</code> preserves the underlying relation if:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">_</span>Preserves₂<span class="ot">_</span>⟶<span class="ot">_</span>⟶<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b c ℓ₁ ℓ₂ ℓ₃<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>        <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B <span class="ot">→</span> C<span class="ot">)</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>        <span class="ot">→</span> Rel A ℓ₁</span>
<span id="cb19-4"><a href="#cb19-4"></a>        <span class="ot">→</span> Rel B ℓ₂</span>
<span id="cb19-5"><a href="#cb19-5"></a>        <span class="ot">→</span> Rel C ℓ₃</span>
<span id="cb19-6"><a href="#cb19-6"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="ot">_</span>+<span class="ot">_</span> Preserves₂ P ⟶ Q ⟶ R <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x y u v<span class="ot">}</span> <span class="ot">→</span> P x y <span class="ot">→</span> Q u v <span class="ot">→</span> R <span class="ot">(</span>x + u<span class="ot">)</span> <span class="ot">(</span>y + v<span class="ot">)</span></span></code></pre></div>
<p>Properties of binary relations:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1"></a>Reflexive <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>        <span class="ot">→</span> Rel A ℓ</span>
<span id="cb20-3"><a href="#cb20-3"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>Reflexive <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">→</span> x ∼ x</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1"></a>Sym <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b ℓ₁ ℓ₂<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>        <span class="ot">→</span> REL A B ℓ₁</span>
<span id="cb21-3"><a href="#cb21-3"></a>        <span class="ot">→</span> REL B A ℓ₂</span>
<span id="cb21-4"><a href="#cb21-4"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>Sym P Q <span class="ot">=</span> P ⇒ flip Q</span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a>Symmetric <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="ot">→</span> Rel A ℓ</span>
<span id="cb21-9"><a href="#cb21-9"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>Symmetric <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> Sym <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>∼<span class="ot">_</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1"></a>Trans <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b c ℓ₁ ℓ₂ ℓ₃<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>        <span class="ot">→</span> REL A B ℓ₁</span>
<span id="cb22-3"><a href="#cb22-3"></a>        <span class="ot">→</span> REL B C ℓ₂</span>
<span id="cb22-4"><a href="#cb22-4"></a>        <span class="ot">→</span> REL A C ℓ₃</span>
<span id="cb22-5"><a href="#cb22-5"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>Trans P Q R <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>i j k<span class="ot">}</span> <span class="ot">→</span> P i j <span class="ot">→</span> Q j k <span class="ot">→</span> R i k</span>
<span id="cb22-7"><a href="#cb22-7"></a></span>
<span id="cb22-8"><a href="#cb22-8"></a>Transitive <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>        <span class="ot">→</span> Rel A ℓ</span>
<span id="cb22-10"><a href="#cb22-10"></a>        <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>Transitive <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">=</span> Trans <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>∼<span class="ot">_</span></span></code></pre></div>
<p>Finally, we define an equivalence relation for binary relations:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">record</span> IsEquivalence <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>                     <span class="ot">(_</span>≈<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="kw">field</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    rfl   <span class="ot">:</span> Reflexive <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    sym   <span class="ot">:</span> Symmetric <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>    trans <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a>  reflexive <span class="ot">:</span> <span class="ot">_</span>≡<span class="ot">_</span> ⇒ <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>  reflexive refl <span class="ot">=</span> rfl</span></code></pre></div>
<h3 id="properties-of-equality">Properties of equality</h3>
<p>We use the new structures to re-define the properties of propositional equality.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">module</span> ≡-properties <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>  sym-≡ <span class="ot">:</span> Symmetric <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> <span class="ot">_</span>≡<span class="ot">_</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  sym-≡ refl <span class="ot">=</span> refl</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a>  trans-≡ <span class="ot">:</span> Transitive <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> <span class="ot">_</span>≡<span class="ot">_</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>  trans-≡ refl p <span class="ot">=</span> p</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a>  isEquivalence <span class="ot">:</span> IsEquivalence <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> <span class="ot">_</span>≡<span class="ot">_</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  isEquivalence <span class="ot">=</span> <span class="kw">record</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>    <span class="ot">{</span> rfl  <span class="ot">=</span> refl</span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="ot">;</span> sym   <span class="ot">=</span> sym-≡</span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="ot">;</span> trans <span class="ot">=</span> trans-≡</span>
<span id="cb24-13"><a href="#cb24-13"></a>    <span class="ot">}</span></span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a>cong-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">{</span>x y <span class="ot">:</span> A<span class="ot">}</span></span>
<span id="cb24-16"><a href="#cb24-16"></a>  <span class="ot">→</span> x ≡ y</span>
<span id="cb24-17"><a href="#cb24-17"></a>  <span class="ot">→</span> f x ≡ f y</span>
<span id="cb24-18"><a href="#cb24-18"></a>cong-≡ f refl <span class="ot">=</span> refl</span>
<span id="cb24-19"><a href="#cb24-19"></a></span>
<span id="cb24-20"><a href="#cb24-20"></a>subs-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}{</span>x y <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">(</span>Predicate <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span></span>
<span id="cb24-21"><a href="#cb24-21"></a>  <span class="ot">→</span> x ≡ y</span>
<span id="cb24-22"><a href="#cb24-22"></a>  <span class="ot">→</span> Predicate x</span>
<span id="cb24-23"><a href="#cb24-23"></a>  <span class="ot">→</span> Predicate y</span>
<span id="cb24-24"><a href="#cb24-24"></a>subs-≡ Predicate refl p <span class="ot">=</span> p</span></code></pre></div>
<h1 id="setoids">Setoids</h1>
<p>Equality, or specifically, equivalence is at the heart of mathematics. In order to build more complex structures, we introduce a new datatype, which essentially encapsulates any datatype and it’s equivalence operation:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">record</span> Setoid c ℓ <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>lsuc <span class="ot">(</span>c ⊔ ℓ<span class="ot">))</span> <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="kw">field</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>    Data          <span class="ot">:</span> <span class="dt">Set</span> c</span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="ot">_</span>≈<span class="ot">_</span>           <span class="ot">:</span> Rel Data ℓ</span>
<span id="cb25-6"><a href="#cb25-6"></a>    isEquivalence <span class="ot">:</span> IsEquivalence <span class="ot">_</span>≈<span class="ot">_</span></span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>  <span class="kw">open</span> IsEquivalence isEquivalence <span class="kw">public</span></span></code></pre></div>
<hr />
<p><a href="./Types.product.html">Product Types / Σ-types</a></p>
</body>
</html>
