<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HoTT/introduction</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.real.html">Previous</a> <a
href="HoTT.identity.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#homotopy-type-theory">Homotopy Type Theory</a></li>
<li><a href="#intensional-and-extensional-type-theories">Intensional and Extensional Type Theories</a></li>
<li><a href="#univalence">Univalence</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="homotopy-type-theory">Homotopy Type Theory</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality

module HoTT.introduction where</code></pre>
<p>Homotopy type theory is a part of a mathematician’s quest to have a formal language in which to write mathematics
such that the correctness of the mathematics written can be automatically verified by a computer program. This
mathematician, Vladimir Voevodsky, played a large part in formalizing homotopy type theory and lead the restructuring of
mathematics based on this new foundation, called Univalent foundations, so that it is easier to implement and work
consistently in these formal languages.</p>
<p>We are working in one such language, Agda, though Voevodsky had used a different one - <a
href="https://coq.inria.fr/">Coq</a>. There are a few more of such languages called <strong>Theorem Provers</strong>,
notably <a href="https://isabelle.in.tum.de/">Isabelle</a>, <a href="https://www.idris-lang.org/">Idris</a>, <a
href="https://arend-lang.github.io/">Arend</a> and <a href="https://leanprover.github.io/">Lean</a>.</p>
<h1 id="intensional-and-extensional-type-theories">Intensional and Extensional Type Theories</h1>
<p>Part of the technical problem that was faced, apart from the need for restructuring and refactoring all of
mathematics, which needed HoTT as a solution, has to deal with how we define equivalences.</p>
<p>In the current system, if say we were to define two types, both representing natural numbers:</p>
<pre class="agda"><code>data ℕ₁ : Set where
  zero₁ : ℕ₁
  succ₁ : ℕ₁ → ℕ₁

data ℕ₂  : Set where
  zero₂ : ℕ₂
  succ₂ : ℕ₂ → ℕ₂</code></pre>
<p>Now two objects, both representing <code>3</code>, will be considered different:</p>
<pre class="agda"><code>three₁ = succ₁ (succ₁ (succ₁ zero₁))
three₂ = succ₂ (succ₂ (succ₂ zero₂))</code></pre>
<pre class="haskell"><code>eq : three₁ ≡ three₂
eq = refl</code></pre>
<p>and the compiler throws the error:</p>
<pre class="haskell"><code>ℕ₂ !=&lt; ℕ₁
when checking that the expression three₂ has type ℕ₁</code></pre>
<p>In order to make these types equal, we have to define an equality type where we provide a proof that ℕ₁ and ℕ₂ are
equal. This is the consequence of the flavor of type theory that we are using called “Intensional” type theory. In
intensional type theory, one has to explicitly define all equivalences for all objects and some machinery for them to
really work with these structures.</p>
<p>In the above example, we could capture equivalence of integers without much code, however this problem compounds
itself as one builds higher structures, say a group of integers or a real number field. These equivalences can be
captured by <code>Setoid</code>s which are basically objects along with their definition of equivalences “packaged
together” so that their implementations can be hidden. However, like many such foundational patches, the final
implementations result in a mess where the base definitions need additional machinery and one needs to be aware of these
implementations anyway when constructing higher structures. Some areas of mathematics are notably hard, like defining
real numbers. However, for all its shortfalls, an intensional system guarantees that the type checking is decidable.</p>
<p>In particular, intensional type theories lack:</p>
<ol type="1">
<li><strong>Functional extensionality</strong>: Two functions that are pointwise equal are equal.</li>
<li><strong>Propositional extensionality</strong>: Two propositions that are logically equivalent are equal.</li>
<li><strong>Quotients</strong>: We can quotient (subset) a type by an equivalence relation.</li>
</ol>
<p>The above can be technically handled by modeling Types using <code>Setoid</code>s instead of <code>Set</code>.
However, if we need further extensionality by adding:</p>
<ol start="4" type="1">
<li><strong>Set extensionality</strong>: Two sets are equal if they are in a one-to-one correspondence.</li>
</ol>
<p>This creates a problem as two sets can be equal in many different ways. To account for this additional structure, we
could model Types using <code>Groupoid</code>s (also known as a <code>Magma</code>) instead of <code>Setoid</code>s.</p>
<p>Another flavor of type theory, “extensional” defines equivalences as - things that behave the same way are equal
(regardless of their internal implementations). This, in a way, provides a better set of abstractions for working with
mathematics as in order to build towers of abstractions, one needs to hide implementation details. Otherwise imagine one
needing to know the intel instruction set to build a website. The shortfall in the extensional system is that it is
possible to define types that are not decidable. In other words, there is no difference between definitional and
propositional equalities allowing cases where type checking will never terminate. Another problem here is that Set
extensionality cannot be modeled.</p>
<p>As the extensional version has major drawbacks, there becomes a need for restructuring the modeling of equivalence in
intensional type theory to build more extensionality along with cleaner and better abstracted implementations. This is
where Homotopy Type Theory comes in.</p>
<h1 id="univalence">Univalence</h1>
<p>Roughly speaking, the mathematical theory that models equality and equivalence of types using abstractions from
homotopy theory is called Homotopy Type Theory (or HoTT in short). The “Univalence” axiom sits at the core of HoTT and
hence, the resulting type theories that build on HoTT are called “univalent type theories” and the math implemented in
such type theories “univalent mathematics”.</p>
<!-- outline further plan -->
<hr />
<p><a href="./HoTT.identity.html">Identity Types and Paths</a></p>
</body>
</html>
