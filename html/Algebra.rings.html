<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/rings</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.groupProperties.html">Previous</a> <a
href="Algebra.rings2.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#rings">Rings</a>
<ul>
<li><a href="#near-semiring">Near-Semiring</a></li>
<li><a href="#semiring">Semiring</a></li>
<li><a href="#commutative-semiring">Commutative Semiring</a></li>
<li><a href="#ring">Ring</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="rings">Rings</h1>
<p>A ring is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝕊\)</span></li>
<li>Two binary operations: + and −</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li><span class="math inline">\(𝕊\)</span> is an abelian group under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an inverse (−)</li>
<li>has an identity</li>
</ul></li>
<li><span class="math inline">\(𝕊\)</span> is a monoid under multiplication, which implies the operation ★:
<ul>
<li>is associative</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that <span class="math inline">\(∀ x : 𝕖 ★ x = 𝕖\)</span></li>
</ol>
<p>Examples of rings would be natural, real, complex and rational numbers. Any algebra over a ring is also a ring.
Hence, any set of n × n matrices of real numbers also forms a ring. A set of real upper or lower triangular matrices
would also form a ring. The family of rings starts from semirings and goes on with commutative semirings, rings and
commutative rings.</p>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality

module Algebra.rings {a ℓ} {A : Set a} (_==_ : Rel A ℓ) where
  open import Types.operations (_==_)
  open import Algebra.groups (_==_)</code></pre>
<p>The family of rings consist of a set and two binary operations. Each binary operation behaves in a certain way with
the set, taking upon roles from the group family, e.g. one operation can behave like a monoid with respect to the set
while the other one can behave like a group.</p>
<table>
<thead>
<tr>
<th>Object ↓ Operation →</th>
<th><code>+</code> behaves as</th>
<th><code>*</code> behaves as</th>
</tr>
</thead>
<tbody>
<tr>
<td>Near-Semiring</td>
<td>Monoid</td>
<td>Semigroup</td>
</tr>
<tr>
<td>Semiring</td>
<td>Commutative Monoid</td>
<td>Monoid</td>
</tr>
<tr>
<td>Commutative Semiring</td>
<td>Commutative Monoid</td>
<td>Commutative Monoid</td>
</tr>
<tr>
<td>Ring</td>
<td>Abelian Group</td>
<td>Monoid</td>
</tr>
</tbody>
</table>
<p>The <code>*</code> operation interacts with the <code>+</code> operation by folowing the law of distributivity.</p>
<h2 id="near-semiring">Near-Semiring</h2>
<p>We define a Near-Semiring as the most abstract structure in the family of rings. It is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝕊\)</span></li>
<li>Two binary operations: + and *</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li><span class="math inline">\(𝕊\)</span> is an monoid under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>has an identity</li>
</ul></li>
<li><span class="math inline">\(𝕊\)</span> is a semigroup under multiplication, which implies the operation *:
<ul>
<li>is associative</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that <span class="math inline">\(∀ x : 𝕖 * x = 𝕖\)</span></li>
</ol>
<pre class="agda"><code>  record IsNearSemiring (+ * : ★ A) (0# : A) : Set (a ⊔ ℓ) where
    field
      +-isMonoid    : IsMonoid + 0#
      *-isSemigroup : IsSemigroup *
      distribʳ      : * DistributesOverʳ +
      zeroˡ         : LeftZero 0# *

    open IsMonoid +-isMonoid public
      renaming
      ( assoc       to +-assoc
      ; ∙-cong      to +-cong
      ; ∙-congˡ     to +-congˡ
      ; ∙-congʳ     to +-congʳ
      ; identity    to +-identity
      ; identityˡ   to +-identityˡ
      ; identityʳ   to +-identityʳ
      ; isMagma     to +-isMagma
      ; isSemigroup to +-isSemigroup
      )

    open IsSemigroup *-isSemigroup public
      using ()
      renaming
      ( assoc    to *-assoc
      ; ∙-cong   to *-cong
      ; ∙-congˡ  to *-congˡ
      ; ∙-congʳ  to *-congʳ
      ; isMagma  to *-isMagma
      )</code></pre>
<h2 id="semiring">Semiring</h2>
<p>A Semiring is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝕊\)</span></li>
<li>Two binary operations: + and *</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li><span class="math inline">\(𝕊\)</span> is an commutative monoid under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an identity</li>
</ul></li>
<li><span class="math inline">\(𝕊\)</span> is a monoid under multiplication, which implies the operation *:
<ul>
<li>is associative</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that <span class="math inline">\(∀ x : 𝕖 * x = 𝕖\)</span></li>
</ol>
<p>These laws are the same as that of a ring, except for the requirement of addition to have an inverse operation. It is
easier to first describe the semiring with the annihilation element:</p>
<pre class="agda"><code>  record IsSemiringWithoutOne (+ * : ★ A) (0# : A) : Set (a ⊔ ℓ) where
    field
      +-isCommutativeMonoid : IsCommutativeMonoid + 0#
      *-isSemigroup         : IsSemigroup *
      distrib               : * DistributesOver +
      zero                  : Zero 0# *

    open IsCommutativeMonoid +-isCommutativeMonoid public
      using ()
      renaming
      ( isMonoid    to +-isMonoid
      ; comm        to +-comm
      )

    zeroˡ : LeftZero 0# *
    zeroˡ = fst zero

    zeroʳ : RightZero 0# *
    zeroʳ = snd zero

    isNearSemiring : IsNearSemiring + * 0#
    isNearSemiring = record
      { +-isMonoid    = +-isMonoid
      ; *-isSemigroup = *-isSemigroup
      ; distribʳ      = snd distrib
      ; zeroˡ         = zeroˡ
      }

    open IsNearSemiring isNearSemiring public
      hiding (+-isMonoid; zeroˡ)


  record IsSemiringWithoutAnnihilatingZero
    (+ * : ★ A) (0# 1# : A) : Set (a ⊔ ℓ) where

    field
      -- 0# is the identity element of *
      -- 1# is the identity element of +
      +-isCommutativeMonoid : IsCommutativeMonoid + 0#
      *-isMonoid            : IsMonoid * 1#
      distrib               : * DistributesOver +

    open IsCommutativeMonoid +-isCommutativeMonoid public
      renaming
      ( assoc       to +-assoc
      ; ∙-cong      to +-cong
      ; ∙-congˡ     to +-congˡ
      ; ∙-congʳ     to +-congʳ
      ; identity    to +-identity
      ; identityˡ   to +-identityˡ
      ; identityʳ   to +-identityʳ
      ; comm        to +-comm
      ; isMagma     to +-isMagma
      ; isSemigroup to +-isSemigroup
      ; isMonoid    to +-isMonoid
      )

    open IsMonoid *-isMonoid public
      using ()
      renaming
      ( assoc       to *-assoc
      ; ∙-cong      to *-cong
      ; ∙-congˡ     to *-congˡ
      ; ∙-congʳ     to *-congʳ
      ; identity    to *-identity
      ; identityˡ   to *-identityˡ
      ; identityʳ   to *-identityʳ
      ; isMagma     to *-isMagma
      ; isSemigroup to *-isSemigroup
      )</code></pre>
<p>And now the complete definition:</p>
<pre class="agda"><code>  record IsSemiring (+ * : ★ A) (0# 1# : A) : Set (a ⊔ ℓ) where
    field
      isSemiringWithoutAnnihilatingZero :
        IsSemiringWithoutAnnihilatingZero + * 0# 1#
      zero : Zero 0# *

    open IsSemiringWithoutAnnihilatingZero
           isSemiringWithoutAnnihilatingZero public

    isSemiringWithoutOne : IsSemiringWithoutOne + * 0#
    isSemiringWithoutOne = record
      { +-isCommutativeMonoid = +-isCommutativeMonoid
      ; *-isSemigroup         = *-isSemigroup
      ; distrib               = distrib
      ; zero                  = zero
      }

    open IsSemiringWithoutOne isSemiringWithoutOne public
      using
      ( isNearSemiring
      ; zeroˡ
      ; zeroʳ
      )</code></pre>
<p>We can add commutativity of multiplication to the above structures to obtain their commutative versions.</p>
<h2 id="commutative-semiring">Commutative Semiring</h2>
<p>A Commutative Semiring is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝕊\)</span></li>
<li>Two binary operations: + and *</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li><span class="math inline">\(𝕊\)</span> is an commutative monoid under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an identity</li>
</ul></li>
<li><span class="math inline">\(𝕊\)</span> is a commutative monoid under multiplication, which implies the operation *:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that <span class="math inline">\(∀ x : 𝕖 * x = 𝕖\)</span></li>
</ol>
<pre class="agda"><code>  record IsCommutativeSemiringWithoutOne
           (+ * : ★ A) (0# : A) : Set (a ⊔ ℓ) where
    field
      isSemiringWithoutOne : IsSemiringWithoutOne + * 0#
      *-comm               : Commutative *

    open IsSemiringWithoutOne isSemiringWithoutOne public

  record IsCommutativeSemiring (+ * : ★ A) (0# 1# : A) : Set (a ⊔ ℓ) where
    field
      +-isCommutativeMonoid : IsCommutativeMonoid + 0#
      *-isCommutativeMonoid : IsCommutativeMonoid * 1#
      distrib               : * DistributesOver +
      zero                  : Zero 0# *

    private
      module +-CM = IsCommutativeMonoid +-isCommutativeMonoid
      open module *-CM = IsCommutativeMonoid *-isCommutativeMonoid public
             using () renaming (comm to *-comm)

    distribˡ : * DistributesOverˡ +
    distribˡ = fst distrib

    distribʳ : * DistributesOverʳ +
    distribʳ = snd distrib

    zeroʳ : RightZero 0# *
    zeroʳ = snd zero

    zeroˡ : RightZero 0# *
    zeroˡ = snd zero

    isSemiring : IsSemiring + * 0# 1#
    isSemiring = record
      { isSemiringWithoutAnnihilatingZero = record
        { +-isCommutativeMonoid = +-isCommutativeMonoid
        ; *-isMonoid            = *-CM.isMonoid
        ; distrib               = distrib
        }
      ; zero                    = zero
      }

    open IsSemiring isSemiring public
      hiding
      ( distrib; zero; zeroˡ; zeroʳ
      ; +-isCommutativeMonoid
      )

    isCommutativeSemiringWithoutOne :
      IsCommutativeSemiringWithoutOne + * 0#
    isCommutativeSemiringWithoutOne = record
      { isSemiringWithoutOne = isSemiringWithoutOne
      ; *-comm               = *-CM.comm
      }</code></pre>
<h2 id="ring">Ring</h2>
<p>A Ring is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝕊\)</span></li>
<li>Two binary operations: + and *</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li><span class="math inline">\(𝕊\)</span> is an abelian group under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an identity</li>
<li>has an inverse (-)</li>
</ul></li>
<li><span class="math inline">\(𝕊\)</span> is a monoid under multiplication, which implies the operation *:
<ul>
<li>is associative</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that <span class="math inline">\(∀ x : 𝕖 * x = 𝕖\)</span></li>
</ol>
<pre class="agda"><code>  record IsRing (+ * : ★ A) (-_ : ♠ A) (0# 1# : A) : Set (a ⊔ ℓ) where
    field
      +-isAbelianGroup : IsAbelianGroup + 0# -_
      *-isMonoid       : IsMonoid * 1#
      distrib          : * DistributesOver +
      zero             : Zero 0# *

    open IsAbelianGroup +-isAbelianGroup public
      renaming
      ( assoc               to +-assoc
      ; ∙-cong              to +-cong
      ; ∙-congˡ             to +-congˡ
      ; ∙-congʳ             to +-congʳ
      ; identity            to +-identity
      ; identityˡ           to +-identityˡ
      ; identityʳ           to +-identityʳ
      ; inverse             to -‿inverse
      ; inverseˡ            to -‿inverseˡ
      ; inverseʳ            to -‿inverseʳ
      ; ⁻¹-cong             to -‿cong
      ; comm                to +-comm
      ; isMagma             to +-isMagma
      ; isSemigroup         to +-isSemigroup
      ; isMonoid            to +-isMonoid
      ; isCommutativeMonoid to +-isCommutativeMonoid
      ; isGroup             to +-isGroup
      )

    open IsMonoid *-isMonoid public
      using ()
      renaming
      ( assoc       to *-assoc
      ; ∙-cong      to *-cong
      ; ∙-congˡ     to *-congˡ
      ; ∙-congʳ     to *-congʳ
      ; identity    to *-identity
      ; identityˡ   to *-identityˡ
      ; identityʳ   to *-identityʳ
      ; isMagma     to *-isMagma
      ; isSemigroup to *-isSemigroup
      )

    distribˡ : * DistributesOverˡ +
    distribˡ = fst distrib

    distribʳ : * DistributesOverʳ +
    distribʳ = snd distrib

    isSemiringWithoutAnnihilatingZero
      : IsSemiringWithoutAnnihilatingZero + * 0# 1#
    isSemiringWithoutAnnihilatingZero = record
      { +-isCommutativeMonoid = +-isCommutativeMonoid
      ; *-isMonoid            = *-isMonoid
      ; distrib               = distrib
      }

    isSemiring : IsSemiring + * 0# 1#
    isSemiring = record
      { isSemiringWithoutAnnihilatingZero =
          isSemiringWithoutAnnihilatingZero
      ; zero = zero
      }

    open IsSemiring isSemiring public
      using (distrib; isNearSemiring; isSemiringWithoutOne)</code></pre>
<p>and finally, the commutative ring:</p>
<pre class="agda"><code>  record IsCommutativeRing
           (+ * : ★ A) (- : ♠ A) (0# 1# : A) : Set (a ⊔ ℓ) where
    field
      isRing : IsRing + * - 0# 1#
      *-comm : Commutative *

    open IsRing isRing public

    *-isCommutativeMonoid : IsCommutativeMonoid * 1#
    *-isCommutativeMonoid =  record
      { isMonoid    = *-isMonoid
      ; comm        = *-comm
      }

    isCommutativeSemiring : IsCommutativeSemiring + * 0# 1#
    isCommutativeSemiring = record
      { +-isCommutativeMonoid = +-isCommutativeMonoid
      ; *-isCommutativeMonoid = *-isCommutativeMonoid
      ; distrib               = (distribˡ , distribʳ)
      ; zero                  = zero
      }

    open IsCommutativeSemiring isCommutativeSemiring public
      using ( isCommutativeSemiringWithoutOne )</code></pre>
<hr />
<p><a href="./Algebra.rings2.html">Rings and family 2</a></p>
</body>
</html>
