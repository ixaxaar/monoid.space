<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/rings2</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.rings.html">Previous</a> <a
href="Algebra.fields.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#rings-continued">Rings Continued…</a>
<ul>
<li><a href="#near-semiring">Near-Semiring</a></li>
<li><a href="#semiring">Semiring</a></li>
<li><a href="#commutative-semiring">Commutative Semiring</a></li>
<li><a href="#ring">Ring</a></li>
<li><a href="#commutative-ring">Commutative Ring</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="rings-continued">Rings Continued…</h1>
<p>We now define objects of the ring family, as we did for groups.</p>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality

open import Algebra.groups
open import Algebra.groups2
open import Algebra.rings

module Algebra.rings2 where</code></pre>
<h2 id="near-semiring">Near-Semiring</h2>
<pre class="agda"><code>record NearSemiring c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data           : Set c
    _≈_            : Rel Data ℓ
    _+_            : ★ Data
    _*_            : ★ Data
    0#             : Data
    isNearSemiring : IsNearSemiring _≈_ _+_ _*_ 0#

  open IsNearSemiring isNearSemiring public

  +-monoid : Monoid _ _
  +-monoid = record { isMonoid = +-isMonoid }

  open Monoid +-monoid public
    using ()
    renaming
    ( magma     to +-magma
    ; semigroup to +-semigroup
    )

  *-semigroup : Semigroup _ _
  *-semigroup = record { isSemigroup = *-isSemigroup }

  open Semigroup *-semigroup public
    using ()
    renaming ( magma    to *-magma )</code></pre>
<h2 id="semiring">Semiring</h2>
<pre class="agda"><code>record SemiringWithoutOne c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data                 : Set c
    _≈_                  : Rel Data ℓ
    _+_                  : ★ Data
    _*_                  : ★ Data
    0#                   : Data
    isSemiringWithoutOne : IsSemiringWithoutOne _≈_ _+_ _*_ 0#

  open IsSemiringWithoutOne isSemiringWithoutOne public

  nearSemiring : NearSemiring _ _
  nearSemiring = record { isNearSemiring = isNearSemiring }

  open NearSemiring nearSemiring public
    using
    ( +-magma; +-semigroup; +-monoid
    ; *-magma; *-semigroup
    )

  +-commutativeMonoid : CommutativeMonoid _ _
  +-commutativeMonoid =
    record { isCommutativeMonoid = +-isCommutativeMonoid }


record SemiringWithoutAnnihilatingZero c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data       : Set c
    _≈_        : Rel Data ℓ
    _+_        : ★ Data
    _*_        : ★ Data
    0#         : Data
    1#         : Data
    isSemiringWithoutAnnihilatingZero :
      IsSemiringWithoutAnnihilatingZero _≈_ _+_ _*_ 0# 1#

  open IsSemiringWithoutAnnihilatingZero
         isSemiringWithoutAnnihilatingZero public

  +-commutativeMonoid : CommutativeMonoid _ _
  +-commutativeMonoid =
    record { isCommutativeMonoid = +-isCommutativeMonoid }

  open CommutativeMonoid +-commutativeMonoid public
    using ()
    renaming
    ( magma     to +-magma
    ; semigroup to +-semigroup
    ; monoid    to +-monoid
    )

  *-monoid : Monoid _ _
  *-monoid = record { isMonoid = *-isMonoid }

  open Monoid *-monoid public
    using ()
    renaming
    ( magma     to *-magma
    ; semigroup to *-semigroup
    )</code></pre>
<pre class="agda"><code>record Semiring c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data       : Set c
    _≈_        : Rel Data ℓ
    _+_        : ★ Data
    _*_        : ★ Data
    0#         : Data
    1#         : Data
    isSemiring : IsSemiring _≈_ _+_ _*_ 0# 1#

  open IsSemiring isSemiring public

  semiringWithoutAnnihilatingZero : SemiringWithoutAnnihilatingZero _ _
  semiringWithoutAnnihilatingZero = record
    { isSemiringWithoutAnnihilatingZero =
        isSemiringWithoutAnnihilatingZero
    }

  open SemiringWithoutAnnihilatingZero
         semiringWithoutAnnihilatingZero public
    using
    ( +-magma;  +-semigroup
    ; *-magma;  *-semigroup
    ; +-monoid; +-commutativeMonoid
    ; *-monoid
    )

  semiringWithoutOne : SemiringWithoutOne _ _
  semiringWithoutOne =
    record { isSemiringWithoutOne = isSemiringWithoutOne }

  open SemiringWithoutOne semiringWithoutOne public
    using (nearSemiring)</code></pre>
<h2 id="commutative-semiring">Commutative Semiring</h2>
<pre class="agda"><code>record CommutativeSemiringWithoutOne c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data                            : Set c
    _≈_                             : Rel Data ℓ
    _+_                             : ★ Data
    _*_                             : ★ Data
    0#                              : Data
    isCommutativeSemiringWithoutOne :
      IsCommutativeSemiringWithoutOne _≈_ _+_ _*_ 0#

  open IsCommutativeSemiringWithoutOne
         isCommutativeSemiringWithoutOne public

  semiringWithoutOne : SemiringWithoutOne _ _
  semiringWithoutOne =
    record { isSemiringWithoutOne = isSemiringWithoutOne }

  open SemiringWithoutOne semiringWithoutOne public
    using
    ( +-magma; +-semigroup
    ; *-magma; *-semigroup
    ; +-monoid; +-commutativeMonoid
    ; nearSemiring
    )


record CommutativeSemiring c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data                  : Set c
    _≈_                   : Rel Data ℓ
    _+_                   : ★ Data
    _*_                   : ★ Data
    0#                    : Data
    1#                    : Data
    isCommutativeSemiring : IsCommutativeSemiring _≈_ _+_ _*_ 0# 1#

  open IsCommutativeSemiring isCommutativeSemiring public

  semiring : Semiring _ _
  semiring = record { isSemiring = isSemiring }

  open Semiring semiring public
    using
    ( +-magma; +-semigroup
    ; *-magma; *-semigroup
    ; +-monoid; +-commutativeMonoid
    ; *-monoid
    ; nearSemiring; semiringWithoutOne
    ; semiringWithoutAnnihilatingZero
    )

  *-commutativeMonoid : CommutativeMonoid _ _
  *-commutativeMonoid =
    record { isCommutativeMonoid = *-isCommutativeMonoid }

  commutativeSemiringWithoutOne : CommutativeSemiringWithoutOne _ _
  commutativeSemiringWithoutOne = record
    { isCommutativeSemiringWithoutOne = isCommutativeSemiringWithoutOne
    }</code></pre>
<h2 id="ring">Ring</h2>
<pre class="agda"><code>record Ring c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infix  8 -_
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data    : Set c
    _≈_     : Rel Data ℓ
    _+_     : ★ Data
    _*_     : ★ Data
    -_      : ♠ Data
    0#      : Data
    1#      : Data
    isRing  : IsRing _≈_ _+_ _*_ -_ 0# 1#

  open IsRing isRing public

  +-abelianGroup : AbelianGroup _ _
  +-abelianGroup = record { isAbelianGroup = +-isAbelianGroup }

  semiring : Semiring _ _
  semiring = record { isSemiring = isSemiring }

  open Semiring semiring public
    using
    ( +-magma; +-semigroup
    ; *-magma; *-semigroup
    ; +-monoid ; +-commutativeMonoid
    ; *-monoid
    ; nearSemiring; semiringWithoutOne
    ; semiringWithoutAnnihilatingZero
    )

  open AbelianGroup +-abelianGroup public
    using () renaming (group to +-group)</code></pre>
<h2 id="commutative-ring">Commutative Ring</h2>
<pre class="agda"><code>record CommutativeRing c ℓ : Set (lsuc (c ⊔ ℓ)) where
  infix  8 -_
  infixl 7 _*_
  infixl 6 _+_
  infix  4 _≈_
  field
    Data              : Set c
    _≈_               : Rel Data ℓ
    _+_               : ★ Data
    _*_               : ★ Data
    -_                : ♠ Data
    0#                : Data
    1#                : Data
    isCommutativeRing : IsCommutativeRing _≈_ _+_ _*_ -_ 0# 1#

  open IsCommutativeRing isCommutativeRing public

  ring : Ring _ _
  ring = record { isRing = isRing }

  commutativeSemiring : CommutativeSemiring _ _
  commutativeSemiring =
    record { isCommutativeSemiring = isCommutativeSemiring }

  open Ring ring public using (+-group; +-abelianGroup)
  open CommutativeSemiring commutativeSemiring public
    using
    ( +-magma; +-semigroup
    ; *-magma; *-semigroup
    ; +-monoid; +-commutativeMonoid
    ; *-monoid; *-commutativeMonoid
    ; nearSemiring; semiringWithoutOne
    ; semiringWithoutAnnihilatingZero; semiring
    ; commutativeSemiringWithoutOne
    )</code></pre>
<hr />
<p><a href="./Algebra.fields.html">Fields</a></p>
</body>
</html>
