<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Logic/introduction</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Types.identity.html">Previous</a> <a
href="Logic.logicBasics.html">Next</a></p>
<h1 id="introduction-to-logic-and-boolean-algebra">Introduction to Logic and Boolean Algebra</h1>
<hr />
<ul>
<li><a href="#foundations-of-logic">Foundations of Logic</a></li>
<li><a href="#classical-logic-vs-constructive-logic">Classical Logic vs. Constructive Logic</a></li>
<li><a href="#propositions-as-types">Propositions as Types</a></li>
<li><a href="#the-curry-howard-correspondence">The Curry-Howard Correspondence</a></li>
<li><a href="#logic-in-type-theory">Logic in Type Theory</a></li>
<li><a href="#computational-logic">Computational Logic</a></li>
<li><a href="#why-study-logic-in-lean">Why Study Logic in Lean?</a></li>
</ul>
<pre class="lean"><code>import Mathlib.Logic.Basic
import Mathlib.Data.Bool.Basic
import Mathlib.Logic.Equiv.Defs
import Mathlib.Tactic.Basic</code></pre>
<p>Logic forms the bedrock of mathematics, computer science, and rational reasoning itself. While often introduced
through truth tables and symbolic manipulation, logic in type theory—particularly as implemented in Lean—reveals a
profound connection between logical reasoning and computation. This chapter explores how logical concepts emerge
naturally from type-theoretic foundations, providing both computational tools and rigorous mathematical structures.</p>
<h2 id="foundations-of-logic">Foundations of Logic</h2>
<p>Logic, in its most fundamental sense, concerns itself with the principles of valid reasoning. Classical logic,
developed over millennia, deals with statements that are either true or false, and provides rules for combining and
manipulating these statements to derive new truths. Boolean algebra, named after George Boole, formalizes this classical
logic through algebraic structures.</p>
<p>However, type theory offers a different perspective on logic—one that emphasizes <strong>construction</strong> over
<strong>truth values</strong>. Instead of asking “is this statement true or false?”, type theory asks “can we construct
evidence for this statement?” This shift in perspective leads to what we call <strong>constructive logic</strong> or
<strong>intuitionistic logic</strong>.</p>
<h2 id="classical-logic-vs.-constructive-logic">Classical Logic vs. Constructive Logic</h2>
<p>The distinction between classical and constructive logic is crucial for understanding logic in type theory:</p>
<p><strong>Classical Logic:</strong></p>
<ul>
<li>Every statement is either true or false (law of excluded middle)</li>
<li>We can prove something exists by showing its non-existence leads to contradiction</li>
<li>Double negation elimination: <code>¬¬P → P</code></li>
</ul>
<p><strong>Constructive Logic:</strong></p>
<ul>
<li>To prove something exists, we must construct an example</li>
<li>We cannot freely use the law of excluded middle</li>
<li>Emphasis on computational content of proofs</li>
</ul>
<p>In Lean, we work primarily with constructive logic, though classical principles can be imported when needed:</p>
<pre class="lean"><code>-- Constructive approach: to prove existence, provide a witness
example : ∃ n : Nat, n &gt; 5 := ⟨6, by simp⟩

-- Classical approach (when imported)
-- example : ∀ P : Prop, P ∨ ¬P := Classical.em</code></pre>
<h2 id="propositions-as-types">Propositions as Types</h2>
<p>One of the most remarkable insights in type theory is the <strong>propositions-as-types</strong> principle. This
identifies:</p>
<ul>
<li><strong>Propositions</strong> (logical statements) with <strong>types</strong></li>
<li><strong>Proofs</strong> (justifications) with <strong>terms</strong> (inhabitants of types)</li>
<li><strong>Proof construction</strong> with <strong>program construction</strong></li>
</ul>
<p>This means that proving a theorem is equivalent to writing a program of a specific type:</p>
<pre class="lean"><code>-- The proposition &quot;if P then P&quot; corresponds to the function type P → P
def identity_proof (P : Prop) : P → P := fun p =&gt; p

-- The proposition &quot;P and Q implies P&quot; corresponds to P ∧ Q → P
def and_left (P Q : Prop) : P ∧ Q → P := fun ⟨p, q⟩ =&gt; p</code></pre>
<h2 id="the-curry-howard-correspondence">The Curry-Howard Correspondence</h2>
<p>The Curry-Howard correspondence formalizes the connection between logic and computation:</p>
<table>
<thead>
<tr>
<th>Logic</th>
<th>Computation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Proposition</td>
<td>Type</td>
</tr>
<tr>
<td>Proof</td>
<td>Program</td>
</tr>
<tr>
<td>True proposition</td>
<td>Inhabited type</td>
</tr>
<tr>
<td>False proposition</td>
<td>Empty type</td>
</tr>
<tr>
<td>Implication P → Q</td>
<td>Function type P → Q</td>
</tr>
<tr>
<td>Conjunction P ∧ Q</td>
<td>Product type P × Q</td>
</tr>
<tr>
<td>Disjunction P ∨ Q</td>
<td>Sum type P ⊕ Q</td>
</tr>
</tbody>
</table>
<p>This correspondence means that logical reasoning becomes type-directed programming, and vice versa.</p>
<h2 id="logic-in-type-theory">Logic in Type Theory</h2>
<p>In Lean’s type theory, logic is not a separate system but emerges naturally from the type-theoretic foundations:</p>
<pre class="lean"><code>-- Conjunction is product types
#check And -- And : Prop → Prop → Prop
#check And.intro -- And.intro : ∀ {a b : Prop}, a → b → a ∧ b

-- Disjunction is sum types
#check Or -- Or : Prop → Prop → Prop
#check Or.inl -- Or.inl : ∀ {a b : Prop}, a → a ∨ b

-- Negation is defined in terms of falsehood
#check Not -- Not : Prop → Prop
-- ¬P is defined as P → False

-- Implication is function types (built-in)
#check (· → ·) -- Prop → Prop → Prop</code></pre>
<h2 id="computational-logic">Computational Logic</h2>
<p>Unlike classical logic, logic in type theory has <strong>computational content</strong>. Every proof is actually a
program that can be executed:</p>
<pre class="lean"><code>-- A constructive proof of P ∨ ¬P → Q ∨ ¬Q
def decidable_transfer (P Q : Prop) : P ∨ ¬P → Q ∨ ¬Q :=
  fun h =&gt; by
    cases h with
    | inl hp =&gt;
      -- If we have P, we need to decide about Q
      -- In general, we cannot decide Q from P alone
      sorry  -- This shows we cannot prove this constructively in general
    | inr hnp =&gt;
      -- If we have ¬P, we still cannot decide about Q
      sorry

-- However, for decidable propositions, we can:
def decidable_transfer_bool (b c : Bool) : b = true ∨ b = false → c = true ∨ c = false :=
  fun _ =&gt; by
    cases c with
    | true =&gt; exact Or.inl rfl
    | false =&gt; exact Or.inr rfl</code></pre>
<h2 id="why-study-logic-in-lean">Why Study Logic in Lean?</h2>
<p>Studying logic through Lean offers several advantages:</p>
<ol type="1">
<li><strong>Rigor</strong>: Every logical step must be justified formally</li>
<li><strong>Computability</strong>: Proofs are programs that can be executed</li>
<li><strong>Verification</strong>: The type checker ensures correctness</li>
<li><strong>Expressiveness</strong>: Can handle complex mathematical reasoning</li>
<li><strong>Foundations</strong>: Provides deep understanding of logical principles</li>
</ol>
<p>This computational view of logic enables us to:</p>
<ul>
<li>Write programs that are provably correct</li>
<li>Verify mathematical theorems mechanically</li>
<li>Understand the constructive content of classical proofs</li>
<li>Build reliable software systems</li>
</ul>
<p>The following sections will explore these ideas in detail, showing how fundamental logical concepts emerge from and
are implemented in type theory.</p>
<hr />
<p><a href="./Logic.logicBasics.html">Boolean Algebra</a></p>
</body>
</html>
