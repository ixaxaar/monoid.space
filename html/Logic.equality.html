<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Logic/equality</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Logic.logicBasics.html">Previous</a> <a
href="Logic.laws.html">Next</a></p>
<h1 id="equality-in-logic">Equality in Logic</h1>
<hr />
<ul>
<li><a href="#logical-vs-propositional-equality">Logical vs Propositional Equality</a></li>
<li><a href="#boolean-equality">Boolean Equality</a></li>
<li><a href="#equivalence-relations">Equivalence Relations</a>
<ul>
<li><a href="#properties-of-relations">Properties of Relations</a></li>
<li><a href="#equivalence-relation-structure">Equivalence Relation Structure</a></li>
</ul></li>
<li><a href="#logical-equivalence">Logical Equivalence</a></li>
<li><a href="#decidable-equality">Decidable Equality</a></li>
<li><a href="#equality-in-different-contexts">Equality in Different Contexts</a>
<ul>
<li><a href="#equality-of-propositions">Equality of Propositions</a></li>
<li><a href="#equality-of-truth-values">Equality of Truth Values</a></li>
<li><a href="#functional-extensionality">Functional Extensionality</a></li>
</ul></li>
</ul>
<pre class="lean"><code>import Mathlib.Logic.Basic
import Mathlib.Data.Bool.Basic
import Mathlib.Logic.Equiv.Basic
import Mathlib.Logic.Relation.Basic
import Mathlib.Tactic.Basic</code></pre>
<p>While we explored equality comprehensively in the Types chapter, equality takes on special significance in logic.
Here we examine equality from the logical perspective: how equality relates to logical operations, how we can compute
with equality, and how equality structures arise in different logical contexts.</p>
<h2 id="logical-vs-propositional-equality">Logical vs Propositional Equality</h2>
<p>In logic, we encounter different notions of equality depending on whether we’re working with truth values,
propositions, or logical operations:</p>
<pre class="lean"><code>-- Propositional equality: two propositions are the same proposition
example : (True ∧ False) = False := rfl

-- Logical equivalence: two propositions have the same truth value
example : (True ∧ False) ↔ False := ⟨And.right, False.elim⟩

-- Boolean equality: two boolean values are the same
example : (true &amp;&amp; false) = false := rfl

-- These are related but distinct concepts
example (P Q : Prop) : (P = Q) → (P ↔ Q) := fun h =&gt; by rw [h]
-- But the converse is not always true without additional axioms</code></pre>
<h2 id="boolean-equality">Boolean Equality</h2>
<p>In computational logic, equality can be defined in terms of other logical operations:</p>
<pre class="lean"><code>-- Boolean equality using XOR
def bool_eq (a b : Bool) : Bool := !(a ^^ b)

-- Verify this matches built-in equality
example (a b : Bool) : bool_eq a b = (a == b) := by
  cases a &lt;;&gt; cases b &lt;;&gt; rfl

-- Boolean equality truth table
example : bool_eq true true = true := rfl
example : bool_eq true false = false := rfl
example : bool_eq false true = false := rfl
example : bool_eq false false = true := rfl

-- Relationship to XOR: equality is negation of XOR
theorem bool_eq_not_xor (a b : Bool) : bool_eq a b = !(a ^^ b) := rfl

-- Alternative definition using other operations
def bool_eq_alt (a b : Bool) : Bool := (a &amp;&amp; b) || ((!a) &amp;&amp; (!b))

theorem bool_eq_equiv (a b : Bool) : bool_eq a b = bool_eq_alt a b := by
  cases a &lt;;&gt; cases b &lt;;&gt; rfl</code></pre>
<h2 id="equivalence-relations">Equivalence Relations</h2>
<p>Equality is the prototypical equivalence relation. Let’s formalize the general structure:</p>
<h3 id="properties-of-relations">Properties of Relations</h3>
<pre class="lean"><code>-- General relation type
def Relation (α : Type*) := α → α → Prop

-- Reflexivity: every element is related to itself
def Reflexive {α : Type*} (r : Relation α) : Prop := ∀ a, r a a

-- Symmetry: if a relates to b, then b relates to a
def Symmetric {α : Type*} (r : Relation α) : Prop := ∀ a b, r a b → r b a

-- Transitivity: if a relates to b and b relates to c, then a relates to c
def Transitive {α : Type*} (r : Relation α) : Prop := ∀ a b c, r a b → r b c → r a c

-- Examples with equality
example : Reflexive (@Eq Nat) := fun a =&gt; rfl
example : Symmetric (@Eq Nat) := fun a b h =&gt; h.symm
example : Transitive (@Eq Nat) := fun a b c h₁ h₂ =&gt; h₁.trans h₂</code></pre>
<h3 id="equivalence-relation-structure">Equivalence Relation Structure</h3>
<pre class="lean"><code>-- An equivalence relation combines all three properties
structure EquivalenceRel (α : Type*) where
  rel : Relation α
  refl : Reflexive rel
  symm : Symmetric rel
  trans : Transitive rel

-- Equality is the canonical equivalence relation
def equality_equiv_rel (α : Type*) : EquivalenceRel α := {
  rel := Eq,
  refl := fun a =&gt; rfl,
  symm := fun a b h =&gt; h.symm,
  trans := fun a b c h₁ h₂ =&gt; h₁.trans h₂
}

-- Boolean equality is also an equivalence relation
def bool_equality_equiv : EquivalenceRel Bool := {
  rel := fun a b =&gt; a = b,
  refl := fun a =&gt; rfl,
  symm := fun a b h =&gt; h.symm,
  trans := fun a b c h₁ h₂ =&gt; h₁.trans h₂
}

-- Logical equivalence for propositions
def prop_equiv_rel : EquivalenceRel Prop := {
  rel := fun P Q =&gt; P ↔ Q,
  refl := fun P =&gt; Iff.rfl,
  symm := fun P Q h =&gt; h.symm,
  trans := fun P Q R h₁ h₂ =&gt; h₁.trans h₂
}</code></pre>
<h2 id="logical-equivalence">Logical Equivalence</h2>
<p>Logical equivalence (<code>↔︎</code>) is a fundamental concept distinct from equality:</p>
<pre class="lean"><code>-- Two propositions are logically equivalent if they have the same truth value
def LogicallyEquivalent (P Q : Prop) : Prop := P ↔ Q

-- Examples of logical equivalence
theorem double_negation_equiv (P : Prop) : LogicallyEquivalent (¬¬P) P := by
  constructor
  · exact Classical.not_not
  · intro h hnp; exact hnp h

theorem demorgan_equiv (P Q : Prop) :
  LogicallyEquivalent (¬(P ∧ Q)) (¬P ∨ ¬Q) := by
  constructor
  · intro h
    by_cases hp : P
    · by_cases hq : Q
      · exfalso; exact h ⟨hp, hq⟩
      · exact Or.inr hq
    · exact Or.inl hp
  · intro h ⟨hp, hq⟩
    cases h with
    | inl hnp =&gt; exact hnp hp
    | inr hnq =&gt; exact hnq hq

-- Logical equivalence respects logical operations
theorem and_equiv_compat (P₁ P₂ Q₁ Q₂ : Prop) :
  LogicallyEquivalent P₁ P₂ → LogicallyEquivalent Q₁ Q₂ →
  LogicallyEquivalent (P₁ ∧ Q₁) (P₂ ∧ Q₂) := by
  intro ⟨h₁, h₂⟩ ⟨h₃, h₄⟩
  constructor
  · intro ⟨hp₁, hq₁⟩; exact ⟨h₁ hp₁, h₃ hq₁⟩
  · intro ⟨hp₂, hq₂⟩; exact ⟨h₂ hp₂, h₄ hq₂⟩</code></pre>
<h2 id="decidable-equality">Decidable Equality</h2>
<p>Some types have decidable equality—we can compute whether two elements are equal:</p>
<pre class="lean"><code>-- Natural numbers have decidable equality
example (n m : Nat) : Decidable (n = m) := Nat.decidableEq n m

#eval decide (5 = 5)  -- true
#eval decide (5 = 7)  -- false

-- Booleans have decidable equality
example (b c : Bool) : Decidable (b = c) := Bool.decidableEq b c

#eval decide (true = true)   -- true
#eval decide (true = false)  -- false

-- We can implement decidable equality for custom types
inductive Color where | red | green | blue

instance : DecidableEq Color := fun
  | Color.red, Color.red =&gt; Decidable.isTrue rfl
  | Color.green, Color.green =&gt; Decidable.isTrue rfl
  | Color.blue, Color.blue =&gt; Decidable.isTrue rfl
  | Color.red, Color.green =&gt; Decidable.isFalse (by simp)
  | Color.red, Color.blue =&gt; Decidable.isFalse (by simp)
  | Color.green, Color.red =&gt; Decidable.isFalse (by simp)
  | Color.green, Color.blue =&gt; Decidable.isFalse (by simp)
  | Color.blue, Color.red =&gt; Decidable.isFalse (by simp)
  | Color.blue, Color.green =&gt; Decidable.isFalse (by simp)

#eval decide (Color.red = Color.red)    -- true
#eval decide (Color.red = Color.blue)   -- false</code></pre>
<h2 id="equality-in-different-contexts">Equality in Different Contexts</h2>
<h3 id="equality-of-propositions">Equality of Propositions</h3>
<pre class="lean"><code>-- Propositional equality is very strict
example : (True ∧ True) = True := rfl
example : (True ∨ False) = True := rfl

-- But many logically equivalent propositions are not equal
example : (True ∧ True) ≠ True := by
  -- This is actually false! They are propositionally equal
  sorry

-- Let&#39;s check what actually happens
example : (True ∧ True) = True := rfl  -- This works!

-- More interesting examples
example (P : Prop) : (P ∧ True) = P := by
  -- This requires propositional extensionality in general
  sorry</code></pre>
<h3 id="equality-of-truth-values">Equality of Truth Values</h3>
<pre class="lean"><code>-- For decidable propositions, we can compare their truth values
def same_truth_value (P Q : Prop) [Decidable P] [Decidable Q] : Bool :=
  decide P == decide Q

example : same_truth_value (3 = 3) (5 &lt; 10) = true := rfl
example : same_truth_value (3 = 4) (5 &lt; 10) = false := rfl

-- This gives us a computational way to check logical equivalence
-- for decidable propositions
theorem same_truth_iff_equiv (P Q : Prop) [Decidable P] [Decidable Q] :
  same_truth_value P Q = true ↔ (P ↔ Q) := by
  sorry  -- Requires more machinery</code></pre>
<h3 id="functional-extensionality">Functional Extensionality</h3>
<p>For functions, equality means they return equal results on all inputs:</p>
<pre class="lean"><code>-- Two boolean functions are equal if they agree on all inputs
theorem bool_fun_ext (f g : Bool → Bool) :
  (∀ b, f b = g b) → f = g := by
  intro h
  funext b
  exact h b

-- Example: these boolean functions are equal
def f₁ (b : Bool) : Bool := b &amp;&amp; true
def f₂ (b : Bool) : Bool := b

theorem f₁_eq_f₂ : f₁ = f₂ := by
  funext b
  cases b &lt;;&gt; rfl

-- For logical functions (predicates)
theorem pred_ext (P Q : Bool → Prop) :
  (∀ b, P b ↔ Q b) → P = Q := by
  intro h
  funext b
  exact propext (h b)</code></pre>
<p>This exploration of equality in logic shows how the abstract concept of equality manifests in different ways:</p>
<ul>
<li><strong>Computational equality</strong>: Decidable and computable</li>
<li><strong>Logical equivalence</strong>: Same truth conditions</li>
<li><strong>Propositional equality</strong>: Definitional sameness</li>
<li><strong>Functional equality</strong>: Extensional equivalence</li>
</ul>
<p>These different notions of equality are all useful in different contexts, and understanding their relationships is
crucial for effective logical reasoning in type theory.</p>
<hr />
<p><a href="./Logic.laws.html">Laws of Boolean Algebra</a></p>
</body>
</html>
