<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Logic/decidability</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Logic.laws.html">Previous</a> <a
href="Logic.system_f.html">Next</a></p>
<h1 id="decidability">Decidability</h1>
<hr />
<ul>
<li><a href="#the-decision-problem">The Decision Problem</a></li>
<li><a href="#decidable-propositions">Decidable Propositions</a>
<ul>
<li><a href="#the-decidable-type-class">The Decidable Type Class</a></li>
<li><a href="#examples-of-decidable-propositions">Examples of Decidable Propositions</a></li>
</ul></li>
<li><a href="#evidence-vs-computation">Evidence vs Computation</a>
<ul>
<li><a href="#proof-relevant-decision">Proof-Relevant Decision</a></li>
<li><a href="#computational-decision">Computational Decision</a></li>
<li><a href="#bridging-the-gap">Bridging the Gap</a></li>
</ul></li>
<li><a href="#decidability-instances">Decidability Instances</a>
<ul>
<li><a href="#natural-number-equality">Natural Number Equality</a></li>
<li><a href="#natural-number-ordering">Natural Number Ordering</a></li>
<li><a href="#boolean-decidability">Boolean Decidability</a></li>
</ul></li>
<li><a href="#decidable-relations">Decidable Relations</a></li>
<li><a href="#classical-vs-constructive-decidability">Classical vs Constructive Decidability</a></li>
<li><a href="#undecidable-propositions">Undecidable Propositions</a>
<ul>
<li><a href="#the-halting-problem">The Halting Problem</a></li>
<li><a href="#gödels-incompleteness">Gödel’s Incompleteness</a></li>
</ul></li>
<li><a href="#practical-applications">Practical Applications</a>
<ul>
<li><a href="#automation-in-lean">Automation in Lean</a></li>
<li><a href="#proof-by-computation">Proof by Computation</a></li>
</ul></li>
<li><a href="#reflective-programming">Reflective Programming</a></li>
</ul>
<pre class="lean"><code>import Mathlib.Logic.Basic
import Mathlib.Data.Bool.Basic
import Mathlib.Data.Nat.Basic
import Mathlib.Logic.Decidable.Basic
import Mathlib.Tactic.Basic
import Mathlib.Tactic.Decide</code></pre>
<p>One of the most fundamental questions in logic and computer science is: “Given a proposition, can we effectively
determine whether it is true or false?” This is the <strong>decision problem</strong>. In constructive type theory, this
question takes on special significance because it connects logical reasoning with computation. Decidability bridges the
gap between <strong>proof</strong> and <strong>algorithm</strong>, between <strong>evidence</strong> and
<strong>computation</strong>.</p>
<h2 id="the-decision-problem">The Decision Problem</h2>
<p>A proposition is <strong>decidable</strong> if there exists an effective procedure (algorithm) that, given the
proposition, can determine whether it is true or false in finite time. This concept is central to:</p>
<ul>
<li><strong>Automated theorem proving</strong>: Can the computer decide this theorem?</li>
<li><strong>Program verification</strong>: Can we automatically check this property?</li>
<li><strong>Computational logic</strong>: Can we compute with logical statements?</li>
</ul>
<p>In classical logic, every proposition is either true or false (law of excluded middle), but this doesn’t tell us
whether we can <strong>compute</strong> which one it is. In constructive type theory, decidability is about the
<strong>existence of algorithms</strong>.</p>
<pre class="lean"><code>-- Classical view: every proposition has a truth value (non-constructive)
open Classical
example (P : Prop) : P ∨ ¬P := em P

-- Constructive view: we need an algorithm to decide
example (b : Bool) : b = true ∨ b = false := by cases b &lt;;&gt; simp</code></pre>
<h2 id="decidable-propositions">Decidable Propositions</h2>
<h3 id="the-decidable-type-class">The Decidable Type Class</h3>
<p>In Lean, decidability is captured by the <code>Decidable</code> type class:</p>
<pre class="lean"><code>-- The core definition (simplified)
#print Decidable
-- inductive Decidable (p : Prop) : Type where
-- | isFalse : (¬p) → Decidable p
-- | isTrue  : p → Decidable p

-- This provides either a proof or a refutation
def decide_example (P : Prop) [Decidable P] : Bool :=
  match ‹Decidable P› with
  | Decidable.isTrue _  =&gt; true
  | Decidable.isFalse _ =&gt; false

-- More commonly used built-in function
#check decide -- {p : Prop} → [Decidable p] → Bool</code></pre>
<p>The <code>Decidable</code> type provides either:</p>
<ul>
<li>A <strong>proof</strong> that the proposition is true (<code>isTrue</code>)</li>
<li>A <strong>proof</strong> that the proposition is false (<code>isFalse</code>)</li>
</ul>
<p>This is constructive: we don’t just know that P ∨ ¬P, we have an algorithm that produces a proof of whichever is the
case.</p>
<h3 id="examples-of-decidable-propositions">Examples of Decidable Propositions</h3>
<pre class="lean"><code>-- Natural number equality is decidable
#check Nat.decidableEq -- DecidableEq Nat
example : Decidable (3 = 3) := Decidable.isTrue rfl
example : Decidable (3 = 4) := Decidable.isFalse (by simp)

-- We can decide by computation
#eval decide (3 = 3) -- true
#eval decide (3 = 4) -- false

-- Natural number ordering is decidable
example : Decidable (5 ≤ 10) := Decidable.isTrue (by simp)
example : Decidable (10 ≤ 5) := Decidable.isFalse (by simp)

#eval decide (5 ≤ 10) -- true
#eval decide (10 ≤ 5) -- false

-- Complex decidable propositions can be built from simpler ones
example : Decidable ((3 = 3) ∧ (5 ≤ 10)) := by infer_instance
#eval decide ((3 = 3) ∧ (5 ≤ 10)) -- true</code></pre>
<h2 id="evidence-vs-computation">Evidence vs Computation</h2>
<p>Decidability beautifully demonstrates the connection between two views of the same logical statement:</p>
<h3 id="proof-relevant-decision">Proof-Relevant Decision</h3>
<p>We can provide explicit evidence for our decisions:</p>
<pre class="lean"><code>-- Proof-relevant: we get the actual proof or refutation
def nat_eq_decision (n m : Nat) : Decidable (n = m) :=
  if h : n = m then
    Decidable.isTrue h
  else
    Decidable.isFalse h

-- Extract the proof from a positive decision
def extract_proof (n m : Nat) (h : decide (n = m) = true) : n = m := by
  -- The `decide` function can provide constructive evidence
  exact of_decide_eq_true h

-- Example usage
example : 7 = 7 := extract_proof 7 7 rfl</code></pre>
<h3 id="computational-decision">Computational Decision</h3>
<p>We can also work purely computationally:</p>
<pre class="lean"><code>-- Convert decidable proposition to boolean
def prop_to_bool (P : Prop) [Decidable P] : Bool := decide P

-- Boolean function for natural number equality
def nat_eq_bool (n m : Nat) : Bool := decide (n = m)

-- Boolean function for natural number less-than-or-equal
def nat_le_bool (n m : Nat) : Bool := decide (n ≤ m)

#eval nat_eq_bool 5 5  -- true
#eval nat_le_bool 3 7  -- true
#eval nat_le_bool 7 3  -- false</code></pre>
<h3 id="bridging-the-gap">Bridging the Gap</h3>
<p>The beauty of Lean’s approach is that these views are connected:</p>
<pre class="lean"><code>-- From boolean to proposition
theorem decide_true_iff (P : Prop) [Decidable P] : decide P = true ↔ P :=
  ⟨of_decide_eq_true, of_decide_eq_false⟩

-- From proposition to boolean
theorem bool_of_decidable (P : Prop) [Decidable P] :
  (P → decide P = true) ∧ (¬P → decide P = false) :=
  ⟨of_decide_eq_false, of_decide_eq_false⟩

-- Example: prove arithmetical statements by computation
example : 15 * 23 = 345 := by decide
example : 100 &lt; 200 := by decide
example : ¬(17 = 18) := by decide</code></pre>
<h2 id="decidability-instances">Decidability Instances</h2>
<h3 id="natural-number-equality">Natural Number Equality</h3>
<pre class="lean"><code>-- Lean provides decidability for natural number equality
instance : DecidableEq Nat := Nat.decidableEq

-- We can implement our own version
def nat_eq_decidable (n m : Nat) : Decidable (n = m) :=
  match n, m with
  | 0, 0 =&gt; Decidable.isTrue rfl
  | 0, Nat.succ _ =&gt; Decidable.isFalse (by simp)
  | Nat.succ _, 0 =&gt; Decidable.isFalse (by simp)
  | Nat.succ n&#39;, Nat.succ m&#39; =&gt;
    match nat_eq_decidable n&#39; m&#39; with
    | Decidable.isTrue h =&gt; Decidable.isTrue (congrArg Nat.succ h)
    | Decidable.isFalse h =&gt; Decidable.isFalse (fun h&#39; =&gt; h (Nat.succ.inj h&#39;))</code></pre>
<h3 id="natural-number-ordering">Natural Number Ordering</h3>
<pre class="lean"><code>-- Decidable less-than-or-equal for natural numbers
def nat_le_decidable (n m : Nat) : Decidable (n ≤ m) :=
  match n, m with
  | 0, _ =&gt; Decidable.isTrue (Nat.zero_le _)
  | Nat.succ _, 0 =&gt; Decidable.isFalse (Nat.not_succ_le_zero _)
  | Nat.succ n&#39;, Nat.succ m&#39; =&gt;
    match nat_le_decidable n&#39; m&#39; with
    | Decidable.isTrue h =&gt; Decidable.isTrue (Nat.succ_le_succ h)
    | Decidable.isFalse h =&gt; Decidable.isFalse (fun h&#39; =&gt; h (Nat.le_of_succ_le_succ h&#39;))

-- This gives us computational power
example : Decidable (100 ≤ 200) := nat_le_decidable 100 200
example : Decidable (200 ≤ 100) := nat_le_decidable 200 100</code></pre>
<h3 id="boolean-decidability">Boolean Decidability</h3>
<pre class="lean"><code>-- Every boolean equation is decidable
instance (b c : Bool) : Decidable (b = c) := Bool.decidableEq b c

-- Boolean predicates are decidable
def is_true_decidable (b : Bool) : Decidable (b = true) :=
  if h : b = true then
    Decidable.isTrue h
  else
    Decidable.isFalse h

-- Complex boolean expressions
def complex_bool_prop (a b c : Bool) : Prop :=
  (a ∧ b) ∨ (¬a ∧ c) = true

instance (a b c : Bool) : Decidable (complex_bool_prop a b c) := by
  unfold complex_bool_prop
  infer_instance

#eval decide (complex_bool_prop true false true)  -- true</code></pre>
<h2 id="decidable-relations">Decidable Relations</h2>
<p>For binary relations, we can define decidability in terms of all pairs:</p>
<pre class="lean"><code>-- A relation is decidable if we can decide it for any pair
class DecidableRel {α β : Type*} (r : α → β → Prop) where
  decidable_rel : ∀ a b, Decidable (r a b)

-- Natural number equality as a decidable relation
instance : DecidableRel (@Eq Nat) where
  decidable_rel := fun a b =&gt; Nat.decidableEq a b

-- Less-than-or-equal as a decidable relation
instance : DecidableRel (· ≤ · : Nat → Nat → Prop) where
  decidable_rel := Nat.decidableLe

-- Using decidable relations
def find_first_ge (n : Nat) (threshold : Nat) : Option Nat :=
  if decide (n ≥ threshold) then some n
  else if n &lt; 100 then find_first_ge (n + 1) threshold
  else none

#eval find_first_ge 0 50  -- some 50</code></pre>
<h2 id="classical-vs-constructive-decidability">Classical vs Constructive Decidability</h2>
<p>There’s an important distinction between classical and constructive decidability:</p>
<pre class="lean"><code>-- Classical decidability: we know P ∨ ¬P but can&#39;t compute which
open Classical

def classical_decidable (P : Prop) : Decidable P :=
  if h : P then Decidable.isTrue h
  else Decidable.isFalse h

-- This relies on classical logic and doesn&#39;t give us an algorithm

-- Constructive decidability: we have an actual algorithm
def constructive_nat_even (n : Nat) : Decidable (Even n) :=
  if h : n % 2 = 0 then
    Decidable.isTrue ⟨n / 2, by rw [Nat.two_mul_div_two_of_even]; exact Nat.dvd_iff_mod_eq_zero.mp ⟨2, h⟩⟩
  else
    Decidable.isFalse (fun ⟨k, hk⟩ =&gt; h (by rw [hk, Nat.mul_mod, Nat.mod_self]; simp))

-- This actually computes the result
#eval decide (Even 10)  -- true
#eval decide (Even 11)  -- false</code></pre>
<h2 id="undecidable-propositions">Undecidable Propositions</h2>
<p>Not all propositions are decidable. Some famous examples:</p>
<h3 id="the-halting-problem">The Halting Problem</h3>
<pre class="lean"><code>-- We cannot decide if an arbitrary function terminates
-- This is a metamathematical statement, not expressible directly in Lean&#39;s logic
-- But we can give the intuition:

-- Hypothetical: if we could decide termination
axiom terminates : (Nat → Nat) → Prop
axiom termination_decidable : ∀ f, Decidable (terminates f)

-- Then we could construct a paradox (diagonalization argument)
-- This shows such a decision procedure cannot exist</code></pre>
<h3 id="gödels-incompleteness">Gödel’s Incompleteness</h3>
<pre class="lean"><code>-- Some arithmetic statements are undecidable in any consistent formal system
-- For example, the consistency of the system itself

-- We cannot prove within Lean that Lean is consistent
-- (If we could, this would violate Gödel&#39;s second incompleteness theorem)

-- However, we can work with statements that are relatively decidable
def goldbach_conjecture (n : Nat) : Prop :=
  n &gt; 2 ∧ Even n → ∃ p q : Nat, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n

-- We can decide this for any particular n, but the universal statement
-- ∀ n, goldbach_conjecture n is not known to be decidable</code></pre>
<h2 id="practical-applications">Practical Applications</h2>
<h3 id="automation-in-lean">Automation in Lean</h3>
<p>Decidability enables powerful automation:</p>
<pre class="lean"><code>-- The `decide` tactic can prove decidable goals automatically
example : 1000 + 2000 = 3000 := by decide
example : 50 &lt; 100 ∧ 100 &lt; 200 := by decide
example : ¬(List.length [1, 2, 3] = 5) := by decide

-- Complex arithmetic
example : (15 * 23 + 7) * 2 = 704 := by decide

-- Boolean reasoning
example : ∀ a b : Bool, a ∧ (a ∨ b) = a := by decide</code></pre>
<h3 id="proof-by-computation">Proof by Computation</h3>
<p>We can prove properties by computing:</p>
<pre class="lean"><code>-- Define a computational check
def is_sorted (l : List Nat) : Bool :=
  match l with
  | [] | [_] =&gt; true
  | a :: b :: rest =&gt; a ≤ b &amp;&amp; is_sorted (b :: rest)

-- Prove specific instances by computation
example : is_sorted [1, 2, 3, 5, 8] = true := by decide

-- Connect computational and logical views
theorem is_sorted_correct (l : List Nat) :
  is_sorted l = true ↔ List.Sorted (· ≤ ·) l := by
  -- Proof would require induction and lemmas about List.Sorted
  sorry

-- Now we can prove sortedness by computation
example : List.Sorted (· ≤ ·) [1, 3, 5, 7, 9] := by
  rw [← is_sorted_correct]
  decide</code></pre>
<h2 id="reflective-programming">Reflective Programming</h2>
<p>Decidability enables <strong>reflection</strong>—treating code as data:</p>
<pre class="lean"><code>-- We can represent propositions as data and decide them
inductive SimpleProp : Type where
  | true : SimpleProp
  | false : SimpleProp
  | and : SimpleProp → SimpleProp → SimpleProp
  | or : SimpleProp → SimpleProp → SimpleProp
  | not : SimpleProp → SimpleProp

-- Interpret simple propositions
def eval_simple_prop : SimpleProp → Bool
  | SimpleProp.true =&gt; true
  | SimpleProp.false =&gt; false
  | SimpleProp.and p q =&gt; eval_simple_prop p &amp;&amp; eval_simple_prop q
  | SimpleProp.or p q =&gt; eval_simple_prop p || eval_simple_prop q
  | SimpleProp.not p =&gt; not (eval_simple_prop p)

-- Decision procedure for simple propositions
def decide_simple_prop : SimpleProp → Bool := eval_simple_prop

-- Example: decide complex formulas by computation
def example_formula : SimpleProp :=
  SimpleProp.or
    (SimpleProp.and SimpleProp.true SimpleProp.false)
    (SimpleProp.not SimpleProp.false)

#eval decide_simple_prop example_formula  -- true</code></pre>
<p>Decidability represents one of type theory’s great achievements: the unification of <strong>logic</strong> and
<strong>computation</strong>. It shows that mathematical truth and algorithmic computation are intimately connected. In
Lean, this connection is not just philosophical but practical—we can prove theorems by running programs, and our proofs
<strong>are</strong> programs.</p>
<p>This computational view of logic opens doors to:</p>
<ul>
<li><strong>Verified computation</strong>: Programs whose correctness is guaranteed by types</li>
<li><strong>Automated reasoning</strong>: Letting computers handle routine proofs</li>
<li><strong>Reflective programming</strong>: Programs that reason about themselves</li>
<li><strong>Constructive mathematics</strong>: Mathematics with computational content</li>
</ul>
<p>The boundary between decidable and undecidable propositions continues to be an active area of research, with profound
implications for both mathematics and computer science.</p>
<hr />
<p><a href="./Logic.system_f.html">System F</a></p>
</body>
</html>
