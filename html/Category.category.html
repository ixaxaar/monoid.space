<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Category/category</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.introduction.html">Previous</a> <a
href="Category.morphisms.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#category">Category</a>
<ul>
<li><a href="#opposite-category">Opposite Category</a></li>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#category-of-sets">Category of Sets</a></li>
<li><a href="#category-of-groups">Category of Groups</a></li>
<li><a href="#category-of-rings">Category of Rings</a></li>
<li><a href="#category-of-topological-spaces">Category of Topological Spaces</a></li>
</ul></li>
</ul></li>
<li><a href="#nerves-of-categories">Nerves of Categories</a>
<ul>
<li><a href="#simplicial-complexes">Simplicial Complexes</a>
<ul>
<li><a href="#simplexes">Simplexes</a></li>
<li><a href="#simplicial-complexes-1">Simplicial Complexes</a></li>
</ul></li>
</ul></li>
<li><a href="#constructions-of-categories">Constructions of Categories</a>
<ul>
<li><a href="#product-category">Product Category</a></li>
<li><a href="#free-category">Free Category</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="category">Category</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality

module Category.category where</code></pre>
<p>A category is the object of study in category theory. It can be thought of being a bunch of objects, which are
associated by a bunch of arrows between those objects, with the arrows being composable and each object having unit
arrows. This minimal structure ensures a multitude of object types studied in mathematics can fit the description.</p>
<p>A category ℂ consists of:</p>
<ol type="1">
<li>A collection of objects <span class="math inline">\(x \in obj(ℂ)\)</span></li>
<li>A collection of morphisms between those objects <span class="math inline">\(hom(𝕔) = \{ f : a → b : a,b ∈ ℂ
\}\)</span>, called a “hom” set</li>
</ol>
<p>such that:</p>
<ol type="1">
<li>Morphisms compose:</li>
</ol>
<p>If <span class="math display">\[f : a → b, g : b → c\]</span> then <span class="math display">\[g ∘ f : a →
c\]</span></p>
<ol start="2" type="1">
<li>Morphisms are associative:</li>
</ol>
<p><span class="math display">\[If~~ f : a → b,~ g : b → c ~~and~~ h : c → d ~~then~~ h ∘ (g ∘ f) = (h ∘ g) ∘
f\]</span></p>
<figure>
<img src="/artwork/covariant_hom_functor.png" alt="Figure 1: Composition" />
<figcaption aria-hidden="true">Figure 1: Composition</figcaption>
</figure>
<ol start="3" type="1">
<li>Morphisms have identities: For every object x, there exists a morphism <span class="math inline">\(1ₓ : x →
x\)</span> called the identity morphism for x, such that for every morphism <span class="math inline">\(f : a →
x\)</span> and every morphism <span class="math inline">\(g : x → b\)</span>, we have <span class="math inline">\(1ₓ ∘ f
= f\)</span> and <span class="math inline">\(g ∘ 1ₓ = g\)</span>.</li>
</ol>
<pre class="agda"><code>record Category (o ℓ e : Level) : Set (suc (o ⊔ ℓ ⊔ e)) where
  infix  4 _≈_ _⇒_
  infixr 9 _∘_

  field
    Obj : Set o                     -- objects
    _⇒_ : Rel Obj ℓ                 -- morphism
    _≈_ : ∀ {A B} → Rel (A ⇒ B) e   -- equivalence of morphisms
    id  : ∀ {A} → (A ⇒ A)           -- identity

    -- composition of morphisms
    _∘_ : ∀ {A B C} → (B ⇒ C) → (A ⇒ B) → (A ⇒ C)

    -- laws
    -- satisfy associativity
    assoc     : ∀ {A B C D} {f : A ⇒ B} {g : B ⇒ C} {h : C ⇒ D} → (h ∘ g) ∘ f ≈ h ∘ (g ∘ f)
    -- satisfy identity
    identityˡ : ∀ {A B} {f : A ⇒ B} → id ∘ f ≈ f
    identityʳ : ∀ {A B} {f : A ⇒ B} → f ∘ id ≈ f
    -- has an equivalence for morphisms
    equiv     : ∀ {A B} → IsEquivalence (_≈_ {A} {B})
    -- composition is congruent on equivalence
    ∘-resp-≈  : ∀ {A B C} {f h : B ⇒ C} {g i : A ⇒ B} → f ≈ h → g ≈ i → f ∘ g ≈ h ∘ i</code></pre>
<h2 id="opposite-category">Opposite Category</h2>
<p>The machinery of category theory also admits a duality, like an object and its mirror image. The opposite or dual of
a category <span class="math inline">\(ℂ\)</span>, denoted by <span class="math inline">\(ℂᴼᵖ\)</span>, is the same
category, but with all morphisms in the opposite direction. All laws and machinery of category theory have their dual
versions.</p>
<pre class="agda"><code>record Categoryᴼᵖ (o ℓ e : Level) : Set (suc (o ⊔ ℓ ⊔ e)) where
  infix  4 _≈_ _⇒_
  infixr 9 _∘_

  field
    Obj : Set o                     -- objects
    _⇒_ : Rel Obj ℓ                 -- morphism
    _≈_ : ∀ {A B} → Rel (B ⇒ A) e   -- equivalence of morphisms
    id  : ∀ {A} → (A ⇒ A)           -- identity

    -- composition of morphisms
    _∘_ : ∀ {A B C} → (B ⇒ A) → (C ⇒ B) → (C ⇒ A)

    -- laws
    -- satisfy associativity
    assoc     : ∀ {A B C D} {f : A ⇒ B} {g : B ⇒ C} {h : C ⇒ D} → h ∘ (g ∘ f) ≈ (h ∘ g) ∘ f
    -- satisfy identity
    identityˡ : ∀ {A B} {f : A ⇒ B} → id ∘ f ≈ f
    identityʳ : ∀ {A B} {f : A ⇒ B} → f ∘ id ≈ f
    -- has an equivalence for morphisms
    equiv     : ∀ {A B} → IsEquivalence (_≈_ {A} {B})
    -- composition is congruent on equivalence
    ∘-resp-≈  : ∀ {A B C} {f h : B ⇒ C} {g i : A ⇒ B} → g ≈ i → f ≈ h → g ∘ f ≈ i ∘ h</code></pre>
<h2 id="examples">Examples</h2>
<p>We can use various mathematical structures to construct categories out of. When defining a category, we have to
decide what our objects and our morphisms would be and how would the morphisms compose. This decision has to be taken in
a way that the conditions of being a category are satisfied (associativity, identity). We would then have a category of
our chosen object.</p>
<h3 id="category-of-sets">Category of Sets</h3>
<p>A category of sets is the simplest of categories we can construct and the most intuitive to understand given we have
been trained to think in terms of sets.</p>
<ul>
<li>Objects: Sets</li>
<li>Morphisms: Total functions between sets</li>
<li>Composition: Function composition</li>
</ul>
<h3 id="category-of-groups">Category of Groups</h3>
<ul>
<li>Objects: Groups</li>
<li>Morphisms: Group homomorphisms</li>
<li>Composition: Composition of group homomorphisms</li>
</ul>
<h3 id="category-of-rings">Category of Rings</h3>
<ul>
<li>Objects: Rings</li>
<li>Morphisms: Ring homomorphisms</li>
<li>Composition: Composition of ring homomorphisms</li>
</ul>
<h3 id="category-of-topological-spaces">Category of Topological Spaces</h3>
<ul>
<li>Objects: Topological Spaces</li>
<li>Morphisms: Continuous maps/functions between spaces</li>
<li>Composition: Composition of continuous maps</li>
</ul>
<p>Here are some other examples:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Objects</th>
<th>Morphisms</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set</td>
<td>sets</td>
<td>total functions</td>
</tr>
<tr>
<td>Group</td>
<td>groups</td>
<td>group homomorphisms</td>
</tr>
<tr>
<td>Top</td>
<td>topological spaces</td>
<td>continuous functions</td>
</tr>
<tr>
<td>Vectₖ</td>
<td>vector spaces over field K</td>
<td>linear transformations</td>
</tr>
<tr>
<td>Poset</td>
<td>partially ordered sets</td>
<td>order-preserving functions</td>
</tr>
<tr>
<td>TopVect</td>
<td>topological vector spaces</td>
<td>continuous linear maps</td>
</tr>
<tr>
<td>𝕄</td>
<td>differentiable manifolds</td>
<td>differentiable maps</td>
</tr>
<tr>
<td>Banach spaces</td>
<td>open subsets of Banach spaces</td>
<td>differentiable maps</td>
</tr>
<tr>
<td>𝕍</td>
<td>vector bundles</td>
<td>vector bundle maps</td>
</tr>
</tbody>
</table>
<p>There are in fact infinitely many more and so we are going to move along now.</p>
<h1 id="nerves-of-categories">Nerves of Categories</h1>
<h2 id="simplicial-complexes">Simplicial Complexes</h2>
<p>Before explaining higher categories, let us look at a structure from algebraic topology called simplexes and
simplicial complexes.</p>
<h3 id="simplexes">Simplexes</h3>
<p>A simplex is an n-dimensional “triangle”. Some examples of the first few dimensional simplices are:</p>
<ul>
<li>0-simplex: point</li>
<li>1-simplex: line segment</li>
<li>2-simplex: triangle</li>
<li>3-simplex: tetrahedron</li>
</ul>
<p>An n-dimensional simplex is also called an <strong>(n+1)-cell</strong>.</p>
<figure>
<img src="/artwork/simplex.png" alt="Figure 5: Simplices" />
<figcaption aria-hidden="true">Figure 5: Simplices</figcaption>
</figure>
<h3 id="simplicial-complexes-1">Simplicial Complexes</h3>
<p>A simplicial complex is a structure formed by gluing together a bunch of simplices. The gluing process has to follow
a set of properties:</p>
<p>A set of simplices <span class="math inline">\(\mathcal{K}\)</span> is a simplicial complex if: - Every face of a
simplex from <span class="math inline">\(\mathcal{K}\)</span> is also in <span
class="math inline">\(\mathcal{K}\)</span> - Intersections of any two simplices is a face of both the simplices</p>
<p>A simplicial complex is of dimension n if the largest dimension of all the constituent simplices is n.</p>
<p><span class="math display">\[
dim(\mathcal{K}) = max(dim(σ_i))
\]</span></p>
<p>Examples:</p>
<ul>
<li>Any n-ary tree is a simplicial complex</li>
<li>An undirected acyclic graph is a 1-dimensional simplicial complex</li>
<li>Any 1-D simplicial complex is a hypergraph</li>
<li>Any n-dimensional convex hull is a simplicial complex</li>
<li>Nerves of any category are simplicial complex</li>
<li>The triangulation of a polygon in the plane is a simplicial complex</li>
</ul>
<p>Simplicial complexes can be used to create or represent topological spaces and serve as a very useful tool. They can
also be used to formalize algebraic constraints in geometric terms as well.</p>
<p>The Nerve N(ℂ) of a category ℂ is a simplicial complex constructed from objects as vertices of simplices and
morphisms of ℂ as the edges.</p>
<figure>
<img src="/artwork/directed_graph.png" alt="Figure 2: Nerves of a category" />
<figcaption aria-hidden="true">Figure 2: Nerves of a category</figcaption>
</figure>
<h1 id="constructions-of-categories">Constructions of Categories</h1>
<h2 id="product-category">Product Category</h2>
<p>Given two (or more) categories, their cartesian product is also a category.</p>
<p>Given two categories ℂ and 𝔻, their product is a category with: - Pairs (C, D) as objects such that C ∈ ℂ and D ∈ 𝔻 -
(f, g) as morphisms where - <span class="math inline">\(f : C_1 → C_2; C_i ∈ ℂ\)</span> - <span class="math inline">\(g
: D_1 → D_2; D_i ∈ 𝔻\)</span> - composition of morphisms defined as <span class="math inline">\((f_1, g_1) ∘ (f_2, g_2)
= (f_1 ∘ f_2, g_1 ∘ g_2)\)</span> - identities defined as <span class="math inline">\(1_{(C, D)} = (1_C,
1_D)\)</span></p>
<h2 id="free-category">Free Category</h2>
<p>Free categories are a result of using a general pattern called “free constructions” for building categories. The idea
of free objects in mathematics can be related to all types of objects with algebraic structure, and provides a general
method of constructing objects using a set of “constructor” objects. The process of construction proceeds as
follows:</p>
<ol type="1">
<li>Take a set of objects to construct the free category with</li>
<li>Construct all possible combinations of these objects, in other words, the power set of the set of those objects.
These form the algebraic object of interest</li>
<li>Define relations between every pair of objects according to the kind of algebraic object to construct</li>
</ol>
<p>For free categories these rules become:</p>
<ol type="1">
<li>Consider a bunch of objects to be taken as generators</li>
<li>Construct the power set of these generators, these form the objects of the free category</li>
<li>Define morphisms between every pair of objects and all compositions of their morphisms, together they form the
hom-set of the free category</li>
</ol>
<p><a href="./Category.morphisms.html">Morphisms</a></p>
</body>
</html>
