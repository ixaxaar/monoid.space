<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../css/agda.css" type="text/css" />
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#equational-reasoning">Equational Reasoning</a></li>
<li><a href="#trivial-example">Trivial example</a></li>
<li><a href="#equational-reasoning-over-equivalence-relations">Equational Reasoning over equivalence relations</a></li>
<li><a href="#some-proofs-using-equational-reasoning">Some Proofs using equational reasoning</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="equational-reasoning">Equational Reasoning</h1>
<p>We now look at constructing a language or algebra atop a given relation and some of its properties. This serves as a nicer way of proving things by application of relations such as chains of transitivity.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="pp">{-# OPTIONS --without-K #-}</span>

<span class="kw">module</span> Algebra<span class="ot">.</span>equational <span class="kw">where</span>

<span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">using</span> <span class="ot">(</span>Level<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_;</span> lsuc<span class="ot">;</span> lzero<span class="ot">)</span>
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>equality
<span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>typeBasics <span class="kw">using</span> <span class="ot">(</span>Σ<span class="ot">;</span> <span class="ot">_</span>,<span class="ot">_)</span></code></pre></div>
<h2 id="trivial-example">Trivial example</h2>
<p>Given an equivalence relation <code>_≡_</code>, we have reflexivity, transitivity and symmetry to apply around. We can perform algebra on terms like <code>a ≡ b</code> using a combination of these laws, e.g. we could chain transitivity bounded by reflexivity into chains looking like:</p>
<p><code>refl - transitive - transitive - transitive - refl</code></p>
<p>This provides a more convenient way of writing proofs similar to how we write them more naturally on paper.</p>
<p>We define a trivial example of an equational reasoning module here:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> ≡-Reasoning <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>≡<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="ot">(</span>Eq <span class="ot">:</span> IsEquivalence <span class="ot">_</span>≡<span class="ot">_)</span> <span class="kw">where</span>
  <span class="kw">open</span> IsEquivalence Eq

  <span class="kw">infix</span>  <span class="dv">3</span> <span class="ot">_</span>∎
  <span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>≡⟨⟩<span class="ot">_</span> <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span>
  <span class="kw">infix</span>  <span class="dv">1</span> begin<span class="ot">_</span>

  begin<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀{</span>x y <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> x ≡ y
  begin<span class="ot">_</span> x≡y <span class="ot">=</span> x≡y

  <span class="ot">_</span>≡⟨⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> x ≡ y
  <span class="ot">_</span> ≡⟨⟩ x≡y <span class="ot">=</span> x≡y

  <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> y ≡ z <span class="ot">→</span> x ≡ z
  <span class="ot">_</span> ≡⟨ x≡y ⟩ y≡z <span class="ot">=</span> trans x≡y y≡z

  <span class="ot">_</span>∎ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ x
  <span class="ot">_</span>∎ <span class="ot">_</span> <span class="ot">=</span> rfl

<span class="co">----</span></code></pre></div>
<p>We could use this to, say prove transitivity and commutativity of addition of natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="ot">:</span> ℕ
  succ <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ

<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ
m + zero   <span class="ot">=</span> m
m + succ n <span class="ot">=</span> succ <span class="ot">(</span>m + n<span class="ot">)</span></code></pre></div>
<p>We can now prove transitivity of <code>+</code>:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> +-properties <span class="ot">{</span>ℓ<span class="ot">}</span> <span class="ot">(_</span>≡<span class="ot">_</span> <span class="ot">:</span> Rel ℕ ℓ<span class="ot">)</span> <span class="ot">(</span>Eq <span class="ot">:</span> IsEquivalence <span class="ot">_</span>≡<span class="ot">_)</span> <span class="kw">where</span>
  <span class="kw">open</span> ≡-Reasoning <span class="ot">_</span>≡<span class="ot">_</span> Eq <span class="kw">public</span>
  <span class="kw">open</span> IsEquivalence Eq <span class="kw">public</span>

  trans-+ <span class="ot">:</span> <span class="ot">{</span>x y z <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> y ≡ z <span class="ot">→</span> x ≡ z
  trans-+ <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">{</span>z<span class="ot">}</span> x≡y y≡z <span class="ot">=</span> begin
    x ≡⟨ x≡y ⟩
    y ≡⟨ y≡z ⟩
    z ∎</code></pre></div>
<!-- To prove the law of commutativity of `+`, we need some properties of equality, like congruence `cong-≡`:

```lll
  open import Algebra.operations _≡_

  +-identityˡ : LeftIdentity zero _+_
  +-identityˡ _ = refl
```

```lll
  comm+ : ∀ {x, y} → x + y ≡ y + x
  comm+ x zero =
```

  comm+ x (succ y) = begin
    succ (x + y) ≡⟨ succ (sym x y) ⟩
    succ (y + x) ≡⟨ rfl  ⟩
    (succ y) + x ∎
 -->
<p>We now define a more complex version where there is symmetry in equivalence preservation, unlike the previous naive version where it is only covariant, capturing the commutativity of the equivalence relation.</p>
<h2 id="equational-reasoning-over-equivalence-relations">Equational Reasoning over equivalence relations</h2>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> ★-reasoning
  <span class="ot">{</span>a ℓ<span class="ot">}</span>
  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
  <span class="ot">(_</span>∼<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span>
  <span class="ot">(</span>reflexive <span class="ot">:</span> Reflexive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>trans <span class="ot">:</span> Transitive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="kw">where</span>

  <span class="kw">infix</span>  <span class="dv">4</span> <span class="ot">_</span>IsRelatedTo<span class="ot">_</span>
  <span class="kw">infix</span>  <span class="dv">3</span> <span class="ot">_</span>∎
  <span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>∼⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">_</span>≡˘⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">_</span>≡⟨⟩<span class="ot">_</span>
  <span class="kw">infix</span>  <span class="dv">1</span> begin<span class="ot">_</span></code></pre></div>
<p>We start with a vague notion of being related to:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="kw">data</span> <span class="ot">_</span>IsRelatedTo<span class="ot">_</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ ℓ<span class="ot">)</span> <span class="kw">where</span>
    relTo <span class="ot">:</span> <span class="ot">(</span>x∼y <span class="ot">:</span> x ∼ y<span class="ot">)</span> <span class="ot">→</span> x IsRelatedTo y</code></pre></div>
<p>we concretize the fact of being related to into a <code>begin</code> statement, this forms the basis or starting point of any reasoning sequence.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  begin<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y<span class="ot">}</span> <span class="ot">→</span> x IsRelatedTo y <span class="ot">→</span> x ∼ y
  begin relTo x∼y <span class="ot">=</span> x∼y</code></pre></div>
<p>chaining transitivity:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>∼⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">→</span> x ∼ y <span class="ot">→</span> y IsRelatedTo z <span class="ot">→</span> x IsRelatedTo z
  <span class="ot">_</span> ∼⟨ x∼y ⟩ relTo y∼z <span class="ot">=</span> relTo <span class="ot">(</span>trans x∼y y∼z<span class="ot">)</span></code></pre></div>
<p>covariant equivalence preservation:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> y IsRelatedTo z <span class="ot">→</span> x IsRelatedTo z
  <span class="ot">_</span> ≡⟨ refl ⟩ x∼z <span class="ot">=</span> x∼z</code></pre></div>
<p>contravariant equivalence preservation:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>≡˘⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">→</span> y ≡ x <span class="ot">→</span> y IsRelatedTo z <span class="ot">→</span> x IsRelatedTo z
  <span class="ot">_</span> ≡˘⟨ refl ⟩ x∼z <span class="ot">=</span> x∼z</code></pre></div>
<p>preservation of reflexivity:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>≡⟨⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">→</span> x IsRelatedTo y <span class="ot">→</span> x IsRelatedTo y
  <span class="ot">_</span> ≡⟨⟩ x∼y <span class="ot">=</span> <span class="ot">_</span> ≡⟨ refl ⟩ x∼y</code></pre></div>
<p>and we end chains of reasoning with a QED:</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">  <span class="ot">_</span>∎ <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> x IsRelatedTo x
  <span class="ot">_</span>∎ <span class="ot">_</span> <span class="ot">=</span> relTo reflexive</code></pre></div>
<h2 id="some-proofs-using-equational-reasoning">Some Proofs using equational reasoning</h2>
<p>A lot of assymetric laws can be derived with one half of the symmetry and mixing it with commutativity. E.g. left inverse coiuld be derived using right inverse and commutativity, similarly, right inverse can be derived using left inverse and commutativity.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>operations

<span class="kw">module</span> withCommutativity <span class="ot">{</span>a ℓ<span class="ot">}</span>
  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
  <span class="ot">{_</span>∼<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">}</span>
  <span class="ot">{_</span>•<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>★ <span class="ot">_</span>∼<span class="ot">_)</span> A<span class="ot">}</span>
  <span class="ot">{_</span>⁻¹ <span class="ot">:</span> <span class="ot">(</span>♠ <span class="ot">_</span>∼<span class="ot">_)</span> A<span class="ot">}</span>
  <span class="ot">(</span>reflexive <span class="ot">:</span> Reflexive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>trans <span class="ot">:</span> Transitive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>comm <span class="ot">:</span> Commutative <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>•<span class="ot">_)</span>
  <span class="ot">(</span>ϵ <span class="ot">:</span> A<span class="ot">)</span>
  <span class="kw">where</span>

    <span class="kw">open</span> ★-reasoning <span class="ot">_</span>∼<span class="ot">_</span> reflexive trans <span class="kw">public</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">    comm+invˡ⇒invʳ <span class="ot">:</span>
        LeftInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> RightInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span>
    comm+invˡ⇒invʳ invˡ x <span class="ot">=</span> begin
      x • <span class="ot">(</span>x ⁻¹<span class="ot">)</span> ∼⟨ comm x <span class="ot">(</span>x ⁻¹<span class="ot">)</span> ⟩
      <span class="ot">(</span>x ⁻¹<span class="ot">)</span> • x ∼⟨ invˡ x ⟩
      ϵ          ∎</code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">    comm+invʳ⇒invˡ <span class="ot">:</span> RightInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span> <span class="ot">→</span> LeftInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span>
    comm+invʳ⇒invˡ invʳ x <span class="ot">=</span> begin
      <span class="ot">(</span>x ⁻¹<span class="ot">)</span> • x ∼⟨ comm <span class="ot">(</span>x ⁻¹<span class="ot">)</span> x ⟩
      x • <span class="ot">(</span>x ⁻¹<span class="ot">)</span> ∼⟨ invʳ x ⟩
      ϵ          ∎</code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> withCongruence <span class="ot">{</span>a ℓ<span class="ot">}</span>
  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span>
  <span class="ot">(_</span>∼<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span>
  <span class="ot">(_</span>•<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>★ <span class="ot">_</span>∼<span class="ot">_)</span> A<span class="ot">)</span>
  <span class="ot">(_</span>⁻¹ <span class="ot">:</span> <span class="ot">(</span>♠ <span class="ot">_</span>∼<span class="ot">_)</span> A<span class="ot">)</span>
  <span class="ot">(</span>reflexive <span class="ot">:</span> Reflexive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>trans <span class="ot">:</span> Transitive <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>sym <span class="ot">:</span> Symmetric <span class="ot">_</span>∼<span class="ot">_)</span>
  <span class="ot">(</span>cong <span class="ot">:</span> Congruent₂ <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>•<span class="ot">_)</span>
  <span class="ot">(</span>ϵ <span class="ot">:</span> A<span class="ot">)</span>
  <span class="kw">where</span>

    <span class="kw">open</span> ★-reasoning <span class="ot">_</span>∼<span class="ot">_</span> reflexive trans <span class="kw">public</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">    assoc+id+invʳ⇒invˡ-unique <span class="ot">:</span>
        Associative <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> Identity <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> RightInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> <span class="ot">∀</span> x y
      <span class="ot">→</span> <span class="ot">(</span>x • y<span class="ot">)</span> ∼ ϵ
      <span class="ot">→</span> x ∼ <span class="ot">(</span>y ⁻¹<span class="ot">)</span>
    assoc+id+invʳ⇒invˡ-unique assoc <span class="ot">(</span>idˡ , idʳ<span class="ot">)</span> invʳ x y eq <span class="ot">=</span> begin
      x                ∼⟨ sym <span class="ot">(</span>idʳ x<span class="ot">)</span> ⟩
      x • ϵ            ∼⟨ cong reflexive <span class="ot">(</span>sym <span class="ot">(</span>invʳ y<span class="ot">))</span> ⟩
      x • <span class="ot">(</span>y • <span class="ot">(</span>y ⁻¹<span class="ot">))</span> ∼⟨ sym <span class="ot">(</span>assoc x y <span class="ot">(</span>y ⁻¹<span class="ot">))</span> ⟩
      <span class="ot">(</span>x • y<span class="ot">)</span> • <span class="ot">(</span>y ⁻¹<span class="ot">)</span> ∼⟨ cong eq reflexive ⟩
      ϵ • <span class="ot">(</span>y ⁻¹<span class="ot">)</span>       ∼⟨ idˡ <span class="ot">(</span>y ⁻¹<span class="ot">)</span> ⟩
      y ⁻¹             ∎</code></pre></div>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda">    assoc+id+invˡ⇒invʳ-unique <span class="ot">:</span>
        Associative <span class="ot">_</span>∼<span class="ot">_</span> <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> Identity <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> LeftInverse <span class="ot">_</span>∼<span class="ot">_</span> ϵ <span class="ot">_</span>⁻¹ <span class="ot">_</span>•<span class="ot">_</span>
      <span class="ot">→</span> <span class="ot">∀</span> x y
      <span class="ot">→</span> <span class="ot">(</span>x • y<span class="ot">)</span> ∼ ϵ
      <span class="ot">→</span> y ∼ <span class="ot">(</span>x ⁻¹<span class="ot">)</span>
    assoc+id+invˡ⇒invʳ-unique assoc <span class="ot">(</span>idˡ , idʳ<span class="ot">)</span> invˡ x y eq <span class="ot">=</span> begin
      y                ∼⟨ sym <span class="ot">(</span>idˡ y<span class="ot">)</span> ⟩
      ϵ • y            ∼⟨ cong <span class="ot">(</span>sym <span class="ot">(</span>invˡ x<span class="ot">))</span> reflexive ⟩
      <span class="ot">((</span>x ⁻¹<span class="ot">)</span> • x<span class="ot">)</span> • y ∼⟨ assoc <span class="ot">(</span>x ⁻¹<span class="ot">)</span> x y ⟩
      <span class="ot">(</span>x ⁻¹<span class="ot">)</span> • <span class="ot">(</span>x • y<span class="ot">)</span> ∼⟨ cong reflexive eq ⟩
      <span class="ot">(</span>x ⁻¹<span class="ot">)</span> • ϵ       ∼⟨ idʳ <span class="ot">(</span>x ⁻¹<span class="ot">)</span> ⟩
      x ⁻¹             ∎</code></pre></div>
<hr />
<p><a href="./Algebra.groups.html">Groups and family</a></p>
</body>
</html>
