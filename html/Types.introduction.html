<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Types/introduction</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Lang.debugging.html">Previous</a> <a
href="Types.universe.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#set-theory">Set Theory</a>
<ul>
<li><a href="#basics-of-set-theory">Basics of Set Theory</a>
<ul>
<li><a href="#relations">Relations</a></li>
<li><a href="#operations">Operations</a></li>
<li><a href="#properties-of-operations">Properties of Operations</a></li>
</ul></li>
</ul></li>
<li><a href="#type-theory">Type Theory</a>
<ul>
<li><a href="#implications-of-type-theory">Implications of Type Theory</a>
<ul>
<li><a href="#foundations-of-mathematics">Foundations of Mathematics</a></li>
<li><a href="#programming-language">Programming Language</a></li>
<li><a href="#calculus-for-category-theory">Calculus for Category Theory</a></li>
</ul></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="introduction">Introduction</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Types<span class="ot">.</span>introduction <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures <span class="kw">using</span> <span class="ot">(</span>List<span class="ot">;</span> []<span class="ot">;</span> <span class="ot">_</span>::<span class="ot">_;</span> ℕ<span class="ot">;</span> one<span class="ot">;</span> three<span class="ot">;</span> seven<span class="ot">;</span> nine<span class="ot">)</span></span></code></pre></div>
<p>Type Theory can be thought of as the programming language used to implement math. Instead of the more familiar method
of writing symbols on a piece of paper, we represent those symbols as code, which a compiler can then parse and
type-check, thus guaranteeing the code’s (and hence the represented math’s) correctness. Though to programmers this
might seem very natural, it is an extremely powerful method for doing math as the burden of verification becomes
automated − thus significantly reducing testing time.</p>
<p>Most of mathematics, as we know it, is based on the foundations of Set Theory. In order to realize our goal of
implementing math in Type Theory with some real convenience, the foundations need to be shaken up a bit, and
reformulated from the ground-up.</p>
<h1 id="set-theory">Set Theory</h1>
<p>Set Theory is a mathematical theory which studies collections of objects, called <code>set</code>s. These objects,
called <code>member</code>s or <code>element</code>s of the set, can literally be anything. The other main component of
Set Theory is first-order logic, which is used to construct and reason around sets. The language of Set Theory can be
used to define almost all of mathematical objects.</p>
<figure>
<img src="/artwork/set.png" alt="Figure 1: Set" />
<figcaption aria-hidden="true">Figure 1: Set</figcaption>
</figure>
<p>Set Theory has existed for centuries, has underdone several alterations, revisions (rewrites) as well as paradox
removal (bug fixes, if you will). In fact, theories in mathematics follow similar lifecycles as seen in the programming
world (or vice versa to be exact) leading to various flavors / versions / “forks” of the theory. The best-known amongst
them is Zermelo-Fraenkel set theory (ZFC).</p>
<h2 id="basics-of-set-theory">Basics of Set Theory</h2>
<p>Zermelo-Fraenkel Set theory (ZFC) consists of:</p>
<ol type="1">
<li><code>Set</code>s which are a collection of objects.</li>
<li>a propositional first order logic system to create and manipulate these sets.</li>
<li>relations, maps and functions amongst sets.</li>
<li>properties of 3.</li>
</ol>
<h3 id="relations">Relations</h3>
<ol type="1">
<li>Belongs</li>
</ol>
<p>The basic relation of set theory is that of membership: <code>∈</code>, i.e. a statement such as
<code>a ∈ Set A</code> which implies <code>a</code> is an element of the set <code>A</code>.</p>
<ol start="2" type="1">
<li>Equality</li>
</ol>
<p>Two sets <code>A</code> and <code>B</code> are equal if <code>∀ x, x ∈ A iff x ∈ B</code>, read as: for all
<code>x</code>, <code>x</code> is an element of <code>A</code> if and only if <code>x</code> is also an element of
<code>B</code>.</p>
<ol start="3" type="1">
<li>Subsets</li>
</ol>
<p><code>A</code> is a subset of <code>B</code> if every element of <code>A</code> is an element of <code>B</code>,
denoted as <code>A ⊆ B</code>.</p>
<h3 id="operations">Operations</h3>
<p>Given sets <code>A</code> and <code>B</code>, one can perform some basic operations with them yielding the following
sets:</p>
<ul>
<li><p>The set <code>A∪B</code>, called the union of <code>A</code> and <code>B</code>, whose elements are the elements
of <code>A</code> and the elements of <code>B</code>.</p></li>
<li><p>The set <code>A∩B</code>, called the intersection of <code>A</code> and <code>B</code>, whose elements are the
elements common to <code>A</code> and <code>B</code>.</p></li>
<li><p>The set <code>A−B</code>, called the difference of <code>A</code> and <code>B</code>, whose elements are those
elements of <code>A</code> that are not members of <code>B</code>.</p></li>
</ul>
<h3 id="properties-of-operations">Properties of Operations</h3>
<ol type="1">
<li>Associativity</li>
</ol>
<pre class="math"><code>A∪(B∪C)=(A∪B)∪C</code></pre>
<pre class="math"><code>A∩(B∩C)=(A∩B)∩C</code></pre>
<ol start="2" type="1">
<li>Commutativity</li>
</ol>
<pre class="math"><code>A∪B=B∪A</code></pre>
<pre class="math"><code>A∩B=B∩A</code></pre>
<ol start="3" type="1">
<li>Distributivity</li>
</ol>
<pre class="math"><code>A∪(B∩C)=(A∪B)∩(A∪C)</code></pre>
<pre class="math"><code>A∩(B∪C)=(A∩B)∪(A∩C)</code></pre>
<ol start="4" type="1">
<li>Idempotency</li>
</ol>
<pre class="math"><code>A∪A=A</code></pre>
<pre class="math"><code>A∩A=A</code></pre>
<pre class="math"><code>A∪∅=A</code></pre>
<pre class="math"><code>A∩∅=∅</code></pre>
<pre class="math"><code>A−A=∅</code></pre>
<p>ZFC comprises of a bunch of axioms, which we are not going to look into here. The interested reader may explore them
on <a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory">Zermelo–Fraenkel set theory:
Wikipedia</a> or <a href="https://ncatlab.org/nlab/show/ZFC#axioms">nlab</a>.</p>
<h1 id="type-theory">Type Theory</h1>
<p>Type theory is a formal system of symbolic logic where every term has a “type”. “Term” here refers to mathematical
terms such as variable <code>x</code>, function <code>f</code>, operation <code>★</code> and so on. Bertrand Russell was
the first to propose this theory in order to fix Russell’s Paradox which plagued naive set theory, though Per Martin-Löf
was the one to come up with a more practically useful version of it, called “Intuitionistic Type Theory”.</p>
<figure>
<img src="/artwork/typehierarchy.png" alt="Figure 2: Haskell Type System" />
<figcaption aria-hidden="true">Figure 2: Haskell Type System</figcaption>
</figure>
<p>A type system in programming languages typically specifies data and appears like a tree of objects, where each
successive level tries to represent data more specifically. E.g., A <code>Float</code> is a subtype of
<code>Number</code> and is a more specialized case of a <code>Number</code>.</p>
<figure>
<img src="/artwork/scala-type-system.png" alt="Figure 3: Scala Type System" />
<figcaption aria-hidden="true">Figure 3: Scala Type System</figcaption>
</figure>
<p>In a system of type theory, each term has a type. For example, <code>4</code>, <code>2+2</code> and
<code>2 * 2</code> are all separate terms with the type <code>ℕ</code> for natural numbers. This is indicated as <span
class="math inline">\(2 : ℕ\)</span> or 2 is of type natural number.</p>
<p>Type theories have explicit computation and it is encoded in rules for rewriting terms. These are called “conversion
rules” or, if the rule only works in one direction, a “reduction rule”. For example, <code>2+2</code> and <code>4</code>
are syntactically different terms, but the former reduces to the latter. This reduction is written
<code>2+2 ↠ 4</code>.</p>
<p>Functions in type theory have a special reduction rule: the argument to the function is substituted for every
instance of the parameter in the function definition. Let’s say the function <code>double</code> is defined as
<code>double(x) = x + x</code> or mathematically <span class="math inline">\(double: x ↦ x + x\)</span>. Then, the
function call <code>double 2</code> would be reduced by substituting <code>2</code> for every <code>x</code> in the
function definition. Thus, <code>double 2 ↠ 2+2</code>.</p>
<h2 id="implications-of-type-theory">Implications of Type Theory</h2>
<h3 id="foundations-of-mathematics">Foundations of Mathematics</h3>
<p>Logic itself is subsumed in the plain idea of operations on terms of types, by observing that any type X may be
thought of as the type of terms satisfying some proposition. In fact, propositions are types and thus finding a proof of
the proposition is equivalent to constructing a term of the proposition type. We discuss about this in <a
href="./Types.proofsAsData.html">Proofs as Data</a>.</p>
<h3 id="programming-language">Programming Language</h3>
<p>Since such a proof is constructive, the term witnessing it being a concrete implementation, and since type theory
strictly works by rewriting rules, one may identify the construction of a term in type theory as a program whose output
is a certain type. Under this “proofs as programs”-paradigm, type theory is a mathematical formalization of a
programming language.</p>
<h3 id="calculus-for-category-theory">Calculus for Category Theory</h3>
<p>(Ignore if the reader is not familiar with category theory) If we consider any term <code>t:X</code> to exist in a
context <code>Γ</code> of other terms <code>x:Γ</code>, then <code>t</code> is naturally identified with a “map”
<code>t:Γ→X</code>, hence: with a morphism. Viewed this way the types and terms of type theory are identified,
respectively, with the objects and morphisms of category theory. From this perspective, type theory provides a formal
language for speaking about categories.</p>
<hr />
<p><a href="./Types.universe.html">Universes and families</a></p>
</body>
</html>
