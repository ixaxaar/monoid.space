<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Types/product</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Types.operations.html">Previous</a> <a
href="Types.functions.html">Next</a></p>
<h1 id="products-co-products">Products &amp; Co-products</h1>
<hr />
<ul>
<li><a href="#products--co-products">Products &amp; Co-products</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#products">Products</a>
<ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#products-in-lean">Products in Lean</a></li>
</ul></li>
<li><a href="#co-products">Co-products</a>
<ul>
<li><a href="#definition-1">Definition</a></li>
<li><a href="#co-products-in-lean">Co-products in Lean</a></li>
</ul></li>
<li><a href="#dependent-pair-types">Dependent Pair Types</a></li>
</ul></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Products and co-products are the most basic forms of type constructors in type theory. They are used to combine types
in a way that preserves the information of the original types. Let us first start with a very informal definition of
products and co-products.</p>
<p>Suppose we have a bunch of types <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, etc. A product of
these types is a type that contains all possible combinations of elements from <code>A</code>, <code>B</code>,
<code>C</code>, <code>D</code>, etc. In the context of programming, this is similar to a tuple or a record:</p>
<pre class="scala"><code>case class Tuple2[A, B](a: A, b: B)</code></pre>
<pre class="java"><code>type Tuple2&lt;A, B&gt; = Pair&lt;A, B&gt;</code></pre>
<p>In both the above examples, we define a new type or class (an enclosure) that contains two elements of types
<code>A</code> and <code>B</code>. This is a product type and is a very obvious way to combine types widely used in
programming.</p>
<p>A co-product, on the other hand, is a type that can be either of the types <code>A</code>, <code>B</code>,
<code>C</code>, or <code>D</code>, etc. In programming, this is similar to a “sum” type or a union in Scala:</p>
<pre class="scala"><code>sealed trait Either[A, B]
case class Left[A, B](a: A) extends Either[A, B]
case class Right[A, B](b: B) extends Either[A, B]</code></pre>
<p>or for example Either type in languages like Java:</p>
<pre class="java"><code>interface Either&lt;A, B&gt; {
  A getLeft();
  B getRight();
}</code></pre>
<p>In the above examples of coproducts, we define a new type or class (an enclosure) that can be either of the two types
<code>A</code> or <code>B</code>. This is a co-product type and is a very useful way to often handle errors or
exceptions in programming, another very popular example being the <code>Option</code> type which is specialized to
either contain a result or an error.</p>
<h2 id="products">Products</h2>
<p>In Type Theory, for two given types <code>A</code> and <code>B</code>, the product of <code>A</code> and
<code>B</code> is a type <code>A × B</code> that represents all possible pairs of elements <code>(a, b)</code> where
<code>a : A</code> and <code>b : B</code>.</p>
<pre class="math"><code>A × B = \{ (a, b) \mid a : A, b : B \}</code></pre>
<p>A product can be mapped to its components using two functions <code>fst</code> and <code>snd</code> that extract the
first and second elements of the pair respectively.</p>
<pre class="math"><code>fst : A × B → A</code></pre>
<pre class="math"><code>snd : A × B → B</code></pre>
<h3 id="definition">Definition</h3>
<p>The categorical definition of a product is that it is a type <code>Prod</code> that comes with two projection
functions <code>π₁</code> and <code>π₂</code> that satisfy the following universal property:</p>
<p>Let <code>A \x B</code> be the product type of types <code>A</code> and <code>B</code>. Then for any other type
<code>X</code> which also has functions <code>f : X → A</code> and <code>g : X → B</code>, there exists a unique
function <code>⟨f, g⟩ : X → Prod</code> such that <code>π₁ ∘ ⟨f, g⟩ = f</code> and <code>π₂ ∘ ⟨f, g⟩ = g</code>.</p>
<p>The following diagram illustrates the universal property of a product type:</p>
<pre class="plantuml"><code>@startuml
skinparam defaultTextAlignment center
skinparam backgroundColor transparent

rectangle A
rectangle B
rectangle &quot;A × B&quot; as Prod
rectangle X

Prod -[#black]-&gt; A : π₁
Prod -[#black]-&gt; B : π₂
X -[#blue]-&gt; Prod : ⟨f,g⟩
X -[#red]-&gt; A : f
X -[#red]-&gt; B : g
@enduml</code></pre>
<p>The way this is interpreted is that, consider <code>A × B</code> as a product type of <code>A</code> and
<code>B</code>. Thus <code>A × B</code> is a type that contains pairs of elements <code>(a, b)</code> where
<code>a : A</code> and <code>b : B</code>. However there can be more such types that also contains some form of pairs of
<code>(a:A, b:B)</code> too! Hence we need to distinguish between the true product type and the other types that contain
pairs of <code>(a, b)</code>. To do this, we take advantage of the fact that the product type of <code>A</code> and
<code>B</code> is unique.</p>
<p>Say we have a type <code>X</code> that contains pairs of <code>(a, b)</code> too. Then we can have two functions
<code>f : X → A</code> and <code>g : X → B</code> that map the pairs of <code>X</code> to <code>A</code> and
<code>B</code> respectively. Uniquness of <code>A × B</code> is guaranteed by the fact that for any other
<code>X</code>, there exists a unique function <code>⟨f, g⟩ : X → A × B</code> that maps <code>X</code> to
<code>A × B</code> such that <code>π₁ ∘ ⟨f, g⟩ = f</code> and <code>π₂ ∘ ⟨f, g⟩ = g</code>. This is the universal
property of a product type.</p>
<h3 id="products-in-lean">Products in Lean</h3>
<p>In Lean, we can define a product type as:</p>
<pre class="lean"><code>inductive Prod (A B : Type) : Type
| mk : A → B → Prod</code></pre>
<p>Here, <code>Prod</code> is a type constructor that takes two types <code>A</code> and <code>B</code> and returns a
new type <code>Prod A B</code>. The type <code>Prod A B</code> is then defined as a type that contains all possible
pairs of elements <code>(a, b)</code> where <code>a : A</code> and <code>b : B</code>.</p>
<p>We can also define projection functions <code>fst</code> and <code>snd</code> that extract the first and second
elements from a product type:</p>
<pre class="lean"><code>def fst {A B : Type} : Prod A B → A
| (Prod.mk a b) := a

def snd {A B : Type} : Prod A B → B
| (Prod.mk a b) := b</code></pre>
<p>Now, we can define a simple example of a product type:</p>
<pre class="lean"><code>def pair := Prod.mk 1 &quot;hello&quot;</code></pre>
<p>Here, <code>pair</code> is a product of <code>Nat</code> and <code>String</code>. We can then extract the first and
second elements from <code>pair</code> using the projection functions:</p>
<pre class="lean"><code>#eval fst pair -- 1
#eval snd pair -- &quot;hello&quot;</code></pre>
<p>The above code will return <code>1</code> and <code>"hello"</code> respectively.</p>
<h2 id="co-products">Co-products</h2>
<p>In Type Theory, for two given types <code>A</code> and <code>B</code>, the co-product (or sum) of <code>A</code> and
<code>B</code> is a type <code>A + B</code> that represents all possible values that can be either from <code>A</code>
or from <code>B</code>, along with the information about which type the value came from.</p>
<pre class="math"><code>A + B = \{ inl(a) \mid a : A \} ∪ \{ inr(b) \mid b : B \}</code></pre>
<p>A co-product comes with two injection functions <code>inl</code> and <code>inr</code> that inject values from either
type into the co-product:</p>
<pre class="math"><code>inl : A → A + B</code></pre>
<pre class="math"><code>inr : B → A + B</code></pre>
<h3 id="definition-1">Definition</h3>
<p>The categorical definition of a co-product is that it is a type <code>Sum</code> that comes with two injection
functions <code>i₁</code> and <code>i₂</code> that satisfy the following universal property:</p>
<p>For any type <code>X</code> and functions <code>f : A → X</code> and <code>g : B → X</code>, there exists a unique
function <code>[f, g] : Sum → X</code> such that <code>[f, g] ∘ i₁ = f</code> and <code>[f, g] ∘ i₂ = g</code>.</p>
<p>The following diagram illustrates the universal property of a co-product type:</p>
<pre class="plantuml"><code>@startuml
skinparam defaultTextAlignment center
skinparam backgroundColor transparent

rectangle A
rectangle B
rectangle &quot;A + B&quot; as Sum
rectangle X

A -[#black]-&gt; Sum : i₁
B -[#black]-&gt; Sum : i₂
Sum -[#blue]-&gt; X : [f,g]
A -[#red]-&gt; X : f
B -[#red]-&gt; X : g
@enduml</code></pre>
<p>This can be interpreted as follows: Consider <code>A + B</code> as a co-product type of <code>A</code> and
<code>B</code>. Thus <code>A + B</code> is a type that contains either values from <code>A</code> or values from
<code>B</code>. However, there might be other types that can also represent this choice! Hence we need to distinguish
between the true co-product type and other types that represent this choice. If we have a type <code>X</code> that can
represent this choice, then we can have two functions <code>f : A → X</code> and <code>g : B → X</code> that map values
from <code>A</code> and <code>B</code> to <code>X</code>. The uniqueness of <code>A + B</code> as the true co-product is
guaranteed by the existence of a unique function <code>[f, g] : A + B → X</code> that satisfies the universal
property.</p>
<h3 id="co-products-in-lean">Co-products in Lean</h3>
<p>In Lean, we can define a co-product type as:</p>
<pre class="lean"><code>inductive Sum (A B : Type) : Type
| inl : A → Sum
| inr : B → Sum</code></pre>
<p>Here, <code>Sum</code> is a type constructor that takes two types <code>A</code> and <code>B</code> and returns a new
type <code>Sum A B</code>. The type <code>Sum A B</code> is then defined as a type that can contain either a value of
type <code>A</code> or a value of type <code>B</code>.</p>
<p>We can also define a case analysis function that handles both cases of a sum type:</p>
<pre class="lean"><code>def case_analysis {A B X : Type} (f : A → X) (g : B → X) : Sum A B → X
| (Sum.inl a) := f a
| (Sum.inr b) := g b</code></pre>
<p>Now, we can define simple examples of co-product types:</p>
<pre class="lean"><code>def left := Sum.inl 42
def right := Sum.inr &quot;world&quot;

def toString {A B} [ToString A] [ToString B] : Sum A B → String :=
case_analysis (λ a, s!&quot;left({toString a})&quot;) (λ b, s!&quot;right({toString b})&quot;)

#eval toString left  -- &quot;left(42)&quot;
#eval toString right -- &quot;right(world)&quot;</code></pre>
<h2 id="dependent-pair-types">Dependent Pair Types</h2>
<p>Dependent pair types generalizes the concept of product types by allowing the type of one component to depend on the
value of another component. Unlike simple product types where both types are fixed and independent, dependent pair types
create a relationship where the second type is a function of the value of the first type.</p>
<p>Mathematically, dependent pair types are denoted as Σ-types (sigma types) and are defined as:</p>
<pre class="math"><code>Σ(x : A) B(x) = \{ (a, b) \mid a : A, b : B(a) \}</code></pre>
<p>Here, <code>A</code> is a type and <code>B</code> is a type family indexed by <code>A</code>. The dependent pair
<code>(a, b)</code> consists of a value <code>a : A</code> and a value <code>b : B(a)</code> where <code>B(a)</code> is
the type of the second component that depends on the value of <code>a</code>.</p>
<p>A relatable example for programmers is the type of sized arrays or vectors, where the length of the array is part of
the type itself. In typescript for example, we can define a tuple that can only have 3 elements as:</p>
<pre class="typescript"><code>type Vec3 = [number, number, number];</code></pre>
<p>or using templates in C++:</p>
<pre class="cpp"><code>template &lt;typename T, int N&gt;
struct array {
    T data[N];
};</code></pre>
<p>Other functional programming languages like Haskell sized vectors can be defined as:</p>
<pre class="haskell"><code>data Vector n a where
    Nil  :: Vector 0 a
    Cons :: a -&gt; Vector n a -&gt; Vector (n + 1) a</code></pre>
<p>Though most mainstream languages do not support dependent types, languages like Idris, Agda, and Lean have built-in
support for dependent types.</p>
<p>In Lean, we can define dependent pair types as:</p>
<pre class="lean"><code>inductive Sigma {A : Type} (B : A → Type) : Type
| mk : Π (a : A), B a → Sigma</code></pre>
<p>Here, <code>Sigma</code> is a type constructor that takes a type <code>A</code> and a type family
<code>B : A → Type</code> and returns a new type <code>Sigma B</code>. The type <code>Sigma B</code> is then defined as
a type that contains all possible dependent pairs <code>(a, b)</code> where <code>a : A</code> and
<code>b : B a</code>.</p>
<hr />
<p><a href="./Types.functions.html">Function Types</a></p>
</body>
</html>
