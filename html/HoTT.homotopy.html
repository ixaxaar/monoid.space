<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HoTT/homotopy</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="HoTT.introduction.html">Previous</a> <a
href="HoTT.paths.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#homotopy-theory">Homotopy Theory</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#paths">Paths</a></li>
<li><a href="#homotopy">Homotopy</a></li>
<li><a href="#fundamental-group">Fundamental group</a></li>
<li><a href="#%E2%88%9E-groupoid">∞-groupoid</a>
<ul>
<li><a href="#groupoid">Groupoid</a></li>
<li><a href="#%E2%88%9E-groupoid-1">∞-groupoid</a></li>
</ul></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="homotopy-theory">Homotopy Theory</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality
open import Types.functions

module HoTT.homotopy {a ℓ} {A : Set a} (_==_ : Rel A ℓ) where
  open import Types.operations (_==_)</code></pre>
<h2 id="overview">Overview</h2>
<p>The notion of “space” generally invokes thought of a geometrical structure. The usual spaces one might have
encountered are Euclidean spaces which fit this intuition. In Algebraic Geometry (of which Homotopy Theory is a part),
however, the notion of a space is abstract, and as a consequence while the well known spaces fit into the definition, so
do many other kinds of objects.</p>
<ol type="1">
<li>A topological space is a set of points endowed with an additional structure called a “topology”.</li>
<li>There is a condition called “continuity” imposed on this space, and hence also concepts like a “neighborhood” of
points.</li>
<li>A path is a line joining two points in a topological space. These are also called as continuous maps.</li>
<li>There can be multiple paths between any two points some of which might be similar in some sense, hence there is a
notion of an equivalence between paths, called “homotopy”.</li>
</ol>
<p>Homotopy Theory studies the characteristics of homotopies of paths.</p>
<h2 id="paths">Paths</h2>
<p>Technically, in a topological space 𝕏, a path between two points <code>x</code> and <code>y</code> ∈ 𝕏 can be
represented as a function <code>f</code> that takes a continuous value <code>t</code> and returns a point on the path
<code>f(t)</code> such that the first point is <code>x</code> <span class="math inline">\(f(0) = x\)</span> and the last
point is <code>y</code> <span class="math inline">\(f(1) = y\)</span> and <span class="math inline">\(0 ≤ t ≤
1\)</span>. Paths thus represented are continuous functions.</p>
<figure>
<img src="/artwork/pathType.png" alt="Figure 1: Path" />
<figcaption aria-hidden="true">Figure 1: Path</figcaption>
</figure>
<h2 id="homotopy">Homotopy</h2>
<p>We could take any two paths between the same points and stretch / squeeze one path into another. This process can be
used to capture relationships between two paths and is called <em>homotopy</em>. More formally,</p>
<p>A <em>homotopy</em> between two paths <code>p(t)</code> and <code>q(t)</code> is defined as a continuous function
<code>H(t, h)</code> such that:</p>
<ul>
<li><span class="math inline">\(H(t, 0) = p(t)\)</span></li>
<li><span class="math inline">\(H(t, 1) = q(t)\)</span></li>
<li><span class="math inline">\(H(0, h) = x\)</span></li>
<li><span class="math inline">\(H(1, h) = y\)</span></li>
</ul>
<p>There can exist multiple paths between two objects and hence multiple homotopies between them. Homotopies can be
thought of as 2-dimensional paths or path-of-path if paths are 1-dimensional paths.</p>
<figure>
<img src="/artwork/homotopy.png" alt="Figure 2: Homotopy" />
<figcaption aria-hidden="true">Figure 2: Homotopy</figcaption>
</figure>
<h2 id="fundamental-group">Fundamental group</h2>
<p>Two homotopies <code>H1</code> and <code>H2</code> can themselves be called equivalent if <span
class="math inline">\(H(0, h) = H(1, h) = x₀\)</span>, i.e. if <code>x</code> and <code>y</code> are the same point. We
can use this equivalence relation and the fact that homotopies have inverses (with loops in the opposite direction), to
build a group structure around these homotopies, called as the <em>fundamental group</em>.</p>
<p>Formally, for any point <code>x</code> in a topological space 𝕏, the fundamental group is the group over - Homotopy
equivalence classes as objects at point <code>x₀</code> denoted <span class="math inline">\(π₁(𝕏, x₀)\)</span>. - A
product operation defined on these equivalence classes a such:</p>
<p>Given two paths / loops (γ₁ and γ₂), their product is:</p>
<pre class="math"><code>γ₁ ♢ γ₂ : [1,0] → 𝕏
γ₁ ♢ γ₂ = λ t → if (0 &lt; t &lt; 1÷2) γ₁ (2 * t) else  γ₂ (2 * t - 1)</code></pre>
<p>Thus the loop <code>γ₁ ♢ γ₂</code> first follows the loop γ₁ with “twice the speed” and then follows γ₂ with “twice
the speed”. It is to be noted that we consider all equivalence classes of loops instead of considering all loops as
loops belonging to one equivalence class can be treated as the same.</p>
<figure>
<img src="/artwork/fundamental_group.png" alt="Figure 3: Fundamental Group" />
<figcaption aria-hidden="true">Figure 3: Fundamental Group</figcaption>
</figure>
<p>Note that we take equivalence classes of loops instead of individual loops as all loops belonging to the same
equivalence class are considered equivalent upto homotopy.</p>
<h2 id="groupoid">∞-groupoid</h2>
<p>So far we have:</p>
<ol type="1">
<li>Point in space</li>
<li>Loops over the point</li>
<li>Homotopies over loops</li>
<li>Fundamental group over homotopies</li>
</ol>
<p>If we look at the derivation of homotopies, it seems evident we can continue to go up the ladder and define
homotopies between homotopies and homotopies between homotopies between homotopies and so on till infinity.</p>
<figure>
<img src="/artwork/infty_groupoid.png" alt="Figure 4: ∞-groupoid" />
<figcaption aria-hidden="true">Figure 4: ∞-groupoid</figcaption>
</figure>
<p>Such a structure of infinite levels of homotopies with points followed by paths as base is called the
<em>∞-groupoid</em>.</p>
<h3 id="groupoid-1">Groupoid</h3>
<p>To formally derive an ∞-groupoid, we start with a groupoid, which belongs to the family of groups.</p>
<p>A groupoid is a structure containing:</p>
<ul>
<li>A set <span class="math inline">\(𝔽\)</span></li>
<li>A binary operation: <code>∙</code></li>
</ul>
<p>where:</p>
<ol type="1">
<li><code>∙</code> is a partial function, i.e. it might not exist for every <code>x, y ∈ 𝔽</code>.</li>
<li><code>∙</code> is associative, i.e. <code>x ∙ (y ∙ z) == (x ∙ y) ∙ z</code></li>
<li><code>∙</code> has an identity, i.e. <code>∃ i ∈ A, i ∙ i = i</code></li>
<li>every object <code>x</code> has an inverse <code>x⁻¹</code>, such that <code>((x ⁻¹) ∙ x) == i</code></li>
</ol>
<pre class="agda"><code>  record IsGroupoid (_∙_ : ★ A) (x : A) (_⁻¹ : ♠ A) : Set (a ⊔ ℓ) where
    field
      isEquivalence     : IsEquivalence _==_
      ∙-cong            : Congruent₂ _∙_
      assoc             : Associative _∙_
      identity          : Identity x _∙_
      inverse           : Inverse x _⁻¹ _∙_

    open IsEquivalence isEquivalence public

    ∙-congˡ : LeftCongruent _∙_
    ∙-congˡ y==z = ∙-cong y==z rfl

    ∙-congʳ : RightCongruent _∙_
    ∙-congʳ y==z = ∙-cong rfl y==z

    identityˡ : LeftIdentity x _∙_
    identityˡ = fst identity

    identityʳ : RightIdentity x _∙_
    identityʳ = snd identity

    inverseˡ : LeftInverse x _⁻¹ _∙_
    inverseˡ = fst inverse

    inverseʳ : RightInverse x _⁻¹ _∙_
    inverseʳ = snd inverse

    open import Types.equational2
    open withCongruence _==_ _∙_ _⁻¹ rfl trans sym ∙-cong x public

    -- uniqueness of the inverses
    uniqueˡ-⁻¹ : ∀ α β → (α ∙ β) == x → α == (β ⁻¹)
    uniqueˡ-⁻¹ = assoc+id+invʳ⇒invˡ-unique assoc identity inverseʳ

    uniqueʳ-⁻¹ : ∀ α β → (α ∙ β) == x → β == (α ⁻¹)
    uniqueʳ-⁻¹ = assoc+id+invˡ⇒invʳ-unique assoc identity inverseˡ</code></pre>
<p>Basically, the above structure is a group with partial function instead of total.</p>
<h3 id="groupoid-2">∞-groupoid</h3>
<p>Formally, an infinity-groupoid (∞-groupoid) is a structure</p>
<ul>
<li>A set of objects <code>A</code></li>
<li>A set of morphisms or arrows between those objects</li>
<li>A set of arrows</li>
</ul>
<hr />
<p><a href="./contents.html">Back to Contents</a></p>
</body>
</html>
