<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/fields</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.rings.html">Previous</a> <a
href="./Algebra.fields2.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#fields-and-family">Fields and Family</a>
<ul>
<li><a href="#fields">Fields</a></li>
<li><a href="#ordered-fields">Ordered Fields</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="fields-and-family">Fields and Family</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _âŠ”_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality

module Algebra.fields {a â„“} {A : Set a} (_==_ : Rel A â„“) where
  open import Types.operations (_==_)

  open import Algebra.order (_==_)
  open import Algebra.groups (_==_)
  open import Algebra.rings (_==_)</code></pre>
<h2 id="fields">Fields</h2>
<p>In abstract algebra, a field has a very specific definition, which is different from the physics conception of a
â€œthing spread across spaceâ€. A field is, like real numbers, a bunch of objects (a set) for which addition, subtraction,
multiplication and division operations are defined. Rational numbers, complex numbers as well as the set of binary
values - 0 &amp; 1, like real numbers, fall into this category. Another way to define fields is to define addition,
multiplication and their inverses, i.e.Â subtraction and division, except at â€œ0â€ - the identity element for
multiplication. The formal definition of fields tries to capture all aspects of these operations.</p>
<p>A field is defined as a set with two operations - addition and multiplication. Thus, an operation on a field would be
a function type with the signature <code>F : ğ”½ â†’ ğ”½ â†’ ğ”½</code> where <code>ğ”½</code> is the set of objects in the
field.</p>
<p>A field is a structure containing:</p>
<ul>
<li>A set $ ğ”½ $</li>
<li>Two binary operations: + and âˆ’</li>
</ul>
<p>where:</p>
<ol type="1">
<li>$ ğ”½ $ is an abelian group under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an inverse (âˆ’)</li>
<li>has an identity</li>
</ul></li>
<li>$ ğ”½ $ is an abelian group under multiplication, which implies the operation â˜…:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an inverse (âˆ’)</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element ğ•– such that $ âˆ€ x : ğ•– â˜… x = ğ•– $</li>
</ol>
<p>A field is thus a more restricted version of a Ring, where there are additional requirements of commutativity and
inverse of multiplication.</p>
<pre class="agda"><code>  record IsField (+ * : â˜… A) (-_ Ã·_ : â™  A) (0# 1# : A) : Set (a âŠ” â„“) where
    field
      +-isAbelianGroup : IsAbelianGroup + 0# -_
      *-isAbelianGroup : IsAbelianGroup * 1# Ã·_
      distrib          : * DistributesOver +
      zero             : Zero 0# *

    open IsAbelianGroup +-isAbelianGroup public
      renaming
      ( assoc               to +-assoc
      ; âˆ™-cong              to +-cong
      ; âˆ™-congË¡             to +-congË¡
      ; âˆ™-congÊ³             to +-congÊ³
      ; identity            to +-identity
      ; identityË¡           to +-identityË¡
      ; identityÊ³           to +-identityÊ³
      ; inverse             to -â€¿inverse
      ; inverseË¡            to -â€¿inverseË¡
      ; inverseÊ³            to -â€¿inverseÊ³
      ; â»Â¹-cong             to -â€¿cong
      ; comm                to +-comm
      ; isMagma             to +-isMagma
      ; isSemigroup         to +-isSemigroup
      ; isMonoid            to +-isMonoid
      ; isCommutativeMonoid to +-isCommutativeMonoid
      ; isGroup             to +-isGroup
      )

    open IsAbelianGroup *-isAbelianGroup public
      using ()
      renaming
      ( assoc               to *-assoc
      ; âˆ™-cong              to *-cong
      ; âˆ™-congË¡             to *-congË¡
      ; âˆ™-congÊ³             to *-congÊ³
      ; identity            to *-identity
      ; identityË¡           to *-identityË¡
      ; identityÊ³           to *-identityÊ³
      ; inverse             to Ã·â€¿inverse
      ; inverseË¡            to Ã·â€¿inverseË¡
      ; inverseÊ³            to Ã·â€¿inverseÊ³
      ; â»Â¹-cong             to Ã·â€¿cong
      ; comm                to *-comm
      ; isMagma             to *-isMagma
      ; isSemigroup         to *-isSemigroup
      ; isMonoid            to *-isMonoid
      ; isCommutativeMonoid to *-isCommutativeMonoid
      ; isGroup             to *-isGroup
      )

    isRing : IsRing + * -_ 0# 1#
    isRing = record
      { +-isAbelianGroup = +-isAbelianGroup
      ; *-isMonoid       = *-isMonoid
      ; distrib          = distrib
      ; zero             = zero
      }</code></pre>
<h2 id="ordered-fields">Ordered Fields</h2>
<p>Ordered fields impose an additional restriction on fields: there has to be an order <code>â‰¤</code> between members of
ğ”½. This order is required to be a total order.</p>
<pre class="agda"><code>  record IsOrderedField (+ * : â˜… A) (-_ Ã·_ : â™  A) (_â‰¤_ : Rel A â„“) (0# 1# : A) : Set (a âŠ” â„“) where
    field
      +-isAbelianGroup : IsAbelianGroup + 0# -_
      *-isAbelianGroup : IsAbelianGroup * 1# Ã·_
      distrib          : * DistributesOver +
      zero             : Zero 0# *
      isTotalOrder     : IsTotalOrder _â‰¤_

    open IsAbelianGroup +-isAbelianGroup public
      renaming
      ( assoc               to +-assoc
      ; âˆ™-cong              to +-cong
      ; âˆ™-congË¡             to +-congË¡
      ; âˆ™-congÊ³             to +-congÊ³
      ; identity            to +-identity
      ; identityË¡           to +-identityË¡
      ; identityÊ³           to +-identityÊ³
      ; inverse             to -â€¿inverse
      ; inverseË¡            to -â€¿inverseË¡
      ; inverseÊ³            to -â€¿inverseÊ³
      ; â»Â¹-cong             to -â€¿cong
      ; comm                to +-comm
      ; isMagma             to +-isMagma
      ; isSemigroup         to +-isSemigroup
      ; isMonoid            to +-isMonoid
      ; isCommutativeMonoid to +-isCommutativeMonoid
      ; isGroup             to +-isGroup
      )

    open IsAbelianGroup *-isAbelianGroup public
      using ()
      renaming
      ( assoc               to *-assoc
      ; âˆ™-cong              to *-cong
      ; âˆ™-congË¡             to *-congË¡
      ; âˆ™-congÊ³             to *-congÊ³
      ; identity            to *-identity
      ; identityË¡           to *-identityË¡
      ; identityÊ³           to *-identityÊ³
      ; inverse             to Ã·â€¿inverse
      ; inverseË¡            to Ã·â€¿inverseË¡
      ; inverseÊ³            to Ã·â€¿inverseÊ³
      ; â»Â¹-cong             to Ã·â€¿cong
      ; comm                to *-comm
      ; isMagma             to *-isMagma
      ; isSemigroup         to *-isSemigroup
      ; isMonoid            to *-isMonoid
      ; isCommutativeMonoid to *-isCommutativeMonoid
      ; isGroup             to *-isGroup
      )

    isRing : IsRing + * -_ 0# 1#
    isRing = record
      { +-isAbelianGroup = +-isAbelianGroup
      ; *-isMonoid       = *-isMonoid
      ; distrib          = distrib
      ; zero             = zero
      }</code></pre>
<p>The real and rational numbers form ordered fields.</p>
<hr />
<p><a href="./Algebra.fields2.html">Fields and family 2</a></p>
</body>
</html>
