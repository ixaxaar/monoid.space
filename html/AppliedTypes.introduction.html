<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AppliedTypes/introduction</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#applied-type-theory">Applied Type Theory</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<hr />
<p><a href="contents.html">Contents</a> <a href="Types.equational2.html">Previous</a> <a
href="AppliedTypes.godels_t.html">Next</a></p>
<h1 id="applied-type-theory">Applied Type Theory</h1>
<pre class="agda"><code>module AppliedTypes.introduction where</code></pre>
<p>Type Theory can be a tool for formally modeling various systems and writing proofs about them. These systems can
technically be any system, though practically, real-world usage is minuscule and for niche use-cases, partly driven by
the need for extreme caution or where adherence to formal specifications is paramount. For example, it’s safer to write
programs in such a way that their functionalities are formally proven instead of relying on tests that try to cover or
test as much code and cases as possible. Use-cases include verifying protocols (e.g. in cryptography, cryptographic
applications like cryptocurrencies), combinational circuits, digital circuits with internal memory, software systems in
finance, embedded systems etc. Formal verification is especially big in the electronics hardware space as errors cost
much more, and hence such an audience tends to have their own languages and tools for formal verification, such as
Cadence’s <a
href="https://www.cadence.com/content/cadence-www/global/en_US/home/tools/digital-design-and-signoff/logic-equivalence-checking/conformal-equivalence-checker.html">Conformal
equivalence checker</a>, Mentor Graphics’ <a href="https://www.mentor.com/products/fv/formalpro/">FormalPro</a>,
Synopsys’ <a href="https://www.synopsys.com/implementation-and-signoff/signoff/formality.html">formality</a> etc.
According to Wikipedia, examples of mathematical objects often used to model systems are: finite state machines, labeled
transition systems, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal
semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare
logic.</p>
<p>Similar to how type checking in compiled languages grant a guarantee against runtime failures due to type errors,
formal proofs offer stronger guarantees of equivalence, termination and spec-adherence. Here, we will implement a few
formal systems and model some interesting technologies as applications of type theory and as a demonstration of what can
be done in Agda. Finally, we will see how to use our formally checked code in the outside world.</p>
<hr />
<p><a href="./AppliedTypes.godels_t.html">Gödel’s T</a></p>
</body>
</html>
