<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/groupMorphisms</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.groups2.html">Previous</a> <a
href="Algebra.rings.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#morphisms">Morphisms</a>
<ul>
<li><a href="#homomorphisms">Homomorphisms</a>
<ul>
<li><a href="#magma-homomorphism">Magma homomorphism</a></li>
<li><a href="#semigroup-homomorphism">Semigroup homomorphism</a></li>
<li><a href="#monoid-homomorphism">Monoid Homomorphism</a></li>
<li><a href="#group-homomorphism">Group Homomorphism</a></li>
</ul></li>
<li><a href="#automorphism">Automorphism</a>
<ul>
<li><a href="#monoid-automorphism">Monoid automorphism</a></li>
<li><a href="#group-automorphism">Group automorphism</a></li>
</ul></li>
<li><a href="#toward-isomorphism">Toward Isomorphism</a></li>
<li><a href="#monomorphisms">Monomorphisms</a>
<ul>
<li><a href="#magma-monomorphism">Magma Monomorphism</a></li>
<li><a href="#semigroup-monomorphism">Semigroup Monomorphism</a></li>
<li><a href="#monoid-monomorphism">Monoid Monomorphism</a></li>
<li><a href="#group-monomorphism">Group Monomorphism</a></li>
</ul></li>
<li><a href="#isomorphism">Isomorphism</a>
<ul>
<li><a href="#magma-isomorphism">Magma isomorphism</a></li>
<li><a href="#semigroup-isomorphism">Semigroup isomorphism</a></li>
<li><a href="#monoid-isomorphism">Monoid Isomorphism</a></li>
<li><a href="#group-isomorphism">Group Isomorphism</a></li>
</ul></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="morphisms">Morphisms</h1>
<pre class="agda"><code>module Algebra.groupMorphisms where

open import Agda.Primitive using (Level; _âŠ”_; lsuc; lzero)
open import Types.relations
open import Types.equality
open import Types.functions2

open import Algebra.groups
open import Algebra.groups2</code></pre>
<p>A morphism is a more general concept that applies not only to groups but also to pretty much all algebraic objects.
It can be defined as a structure-preserving map. In the context of group-like objects, a morphism between any two
objects <code>X</code> and <code>Y</code> embeds <code>X</code> in <code>Y</code> while ensuring the structure of
<code>X</code> is preserved.</p>
<p>Let us first define a morphism:</p>
<pre class="agda"><code>module Homomorphism {f t â„“} (From : Set f) (To : Set t) (_==_ : Rel To â„“) where
  Morphism : Set _
  Morphism = From â†’ To</code></pre>
<p>In the family of groups, these are the main kinds of morphisms:</p>
<ol type="1">
<li>Homomorphism</li>
<li>Endomorphism</li>
<li>Isomorphism</li>
<li>Automorphism</li>
</ol>
<h2 id="homomorphisms">Homomorphisms</h2>
<p>A map (function) <code>ğ”½</code> is a homomorphism if given input <code>x âˆˆ (X, â€¢)</code>, where X is a group-like
structure, its output <code>y âˆˆ (Y, âˆ˜)</code> where Y is also a group-like structure, such that <code>ğ”½</code> preserves
the group-like structure of <code>X</code> in <code>Y</code>, i.e.Â it ensures that all relations what were valid in
<code>X</code> remain valid in <code>Y</code>. More formally,</p>
<p>Given two groups, <code>(X, â€¢)</code> and <code>(Y, âˆ˜)</code>, <code>ğ”½ : X â†’ Y</code> is a homomorphism if:</p>
<p><span class="math display">\[
âˆ€ xâ‚, xâ‚‚ âˆˆ X, ğ”½âŸ¦ xâ‚ â€¢ xâ‚‚ âŸ§ = ğ”½âŸ¦ xâ‚ âŸ§ âˆ˜ ğ”½âŸ¦ xâ‚‚ âŸ§
\]</span></p>
<p>The basic rules for any morphism to be a homomorphism are if it:</p>
<ol type="1">
<li>Preserves identity</li>
</ol>
<p>An identity homomorphism when applied to a structure produces the same structure.</p>
<pre class="agda"><code>  identity-preservation : Morphism â†’ From â†’ To â†’ Set _
  identity-preservation ğ•„âŸ¦_âŸ§ from to = ğ•„âŸ¦ from âŸ§ == to</code></pre>
<ol start="2" type="1">
<li>Composes with operations</li>
</ol>
<p>If <code>ğ”½</code> is a homomorphism from <code>X â†’ Y</code>, and <code>â‹…</code> and <code>âˆ˜</code> are both unary or
both binary operations operating on <code>X</code> and <code>Y</code> respectively, then <code>ğ”½</code> composes with
the two operations in the following ways:</p>
<pre class="agda"><code>  compose-unary : Morphism â†’ â™  From â†’ â™  To â†’ Set _
  compose-unary ğ•„âŸ¦_âŸ§ âˆ™_ âˆ˜_ = âˆ€ x â†’ ğ•„âŸ¦ âˆ™ x âŸ§ == ( âˆ˜ ğ•„âŸ¦ x âŸ§ )

  compose-binary : Morphism â†’ â˜… From â†’ â˜… To â†’ Set _
  compose-binary ğ•„âŸ¦_âŸ§ _âˆ™_ _âˆ˜_ = âˆ€ x y â†’ ğ•„âŸ¦ x âˆ™ y âŸ§ == ( ğ•„âŸ¦ x âŸ§ âˆ˜ ğ•„âŸ¦ y âŸ§ )</code></pre>
<p>Now, we define homomorphisms for various group-like structures we have discussed earlier.</p>
<h3 id="magma-homomorphism">Magma homomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Magma f â„“â‚) (To : Magma t â„“â‚‚) where
  private
    module F = Magma From
    module T = Magma To

  open Homomorphism F.Data T.Data T._==_

  record IsMagmaHomomorphism (ğ•„âŸ¦_âŸ§ : Morphism) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      preserves-congruence    : ğ•„âŸ¦_âŸ§ Preserves F._==_ âŸ¶ T._==_
      preserves-composition   : compose-binary ğ•„âŸ¦_âŸ§ F._âˆ™_ T._âˆ™_</code></pre>
<h3 id="semigroup-homomorphism">Semigroup homomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Semigroup f â„“â‚) (To : Semigroup t â„“â‚‚) where
  private
    module F = Semigroup From
    module T = Semigroup To

  open Homomorphism F.Data T.Data T._==_

  record IsSemigroupHomomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-magma-homomorphism  : IsMagmaHomomorphism F.magma T.magma ğ•„âŸ¦_âŸ§

    open IsMagmaHomomorphism is-magma-homomorphism public</code></pre>
<h3 id="monoid-homomorphism">Monoid Homomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Monoid f â„“â‚) (To : Monoid t â„“â‚‚) where
  private
    module F = Monoid From
    module T = Monoid To

  open Homomorphism F.Data T.Data T._==_

  record IsMonoidHomomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-semigroup-homomorphism  : IsSemigroupHomomorphism F.semigroup T.semigroup ğ•„âŸ¦_âŸ§
      preserves-identity         : identity-preservation ğ•„âŸ¦_âŸ§ F.Îµ T.Îµ

    open IsSemigroupHomomorphism is-semigroup-homomorphism public</code></pre>
<h3 id="group-homomorphism">Group Homomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Group f â„“â‚) (To : Group t â„“â‚‚) where
  private
    module F = Group From
    module T = Group To

  open Homomorphism F.Data T.Data T._==_

  record IsGroupHomomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-monoid-homomorphism  : IsMonoidHomomorphism F.monoid T.monoid ğ•„âŸ¦_âŸ§
      preserves-inverse       : compose-unary ğ•„âŸ¦_âŸ§ F._â»Â¹ T._â»Â¹

    open IsMonoidHomomorphism is-monoid-homomorphism public</code></pre>
<h2 id="automorphism">Automorphism</h2>
<p>An Automorphism is a homomorphism between the object to itself.</p>
<h3 id="monoid-automorphism">Monoid automorphism</h3>
<pre class="agda"><code>module _ {f â„“} (Self : Monoid f â„“) where
  private
    module S = Monoid Self

  open Homomorphism S.Data S.Data S._==_

  record IsMonoidAutomorphism (ğ•„âŸ¦_âŸ§ : Morphism) : Set (f âŠ” â„“) where
    field
      is-homomorphism : IsMonoidHomomorphism Self Self ğ•„âŸ¦_âŸ§</code></pre>
<h3 id="group-automorphism">Group automorphism</h3>
<pre class="agda"><code>module _ {f â„“} (Self : Group f â„“) where
  private
    module S = Group Self

  open Homomorphism S.Data S.Data S._==_

  record IsGroupAutomorphism (ğ•„âŸ¦_âŸ§ : Morphism) : Set (f âŠ” â„“) where
    field
      is-homomorphism : IsGroupHomomorphism Self Self ğ•„âŸ¦_âŸ§</code></pre>
<h2 id="toward-isomorphism">Toward Isomorphism</h2>
<p>An group isomorphism is a homomorphism with an additional property - bijection (one-to-one + onto). Bijection implies
an isomorphism is a homomorphism such that the inverse of the homomorphism is also a homomorphism. Practically, an
isomorphism is an equivalence relation. Often in mathematics one encounters the phrase â€œequal upto isomorphismâ€ meaning
isomorphism serves as equality for all practical purposes.</p>
<figure>
<img src="/artwork/functions.png" alt="Injection vs Surjection vs Bijection" />
<figcaption aria-hidden="true">Injection vs Surjection vs Bijection</figcaption>
</figure>
<p>An injective morphism is a Monomorphism. A surjective morphism is an Epimorphism. An isomorphism is both injective
and surjective.</p>
<h2 id="monomorphisms">Monomorphisms</h2>
<p>We first define Monomorphisms:</p>
<h3 id="magma-monomorphism">Magma Monomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Magma f â„“â‚) (To : Magma t â„“â‚‚) where
  private
    module F = Magma From
    module T = Magma To

  open Homomorphism F.Data T.Data T._==_

  record IsMagmaMonomorphism (ğ•„âŸ¦_âŸ§ : Morphism) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-magma-homomorphism   : IsMagmaHomomorphism From To ğ•„âŸ¦_âŸ§
      is-morphism-injective   : Injective ğ•„âŸ¦_âŸ§</code></pre>
<h3 id="semigroup-monomorphism">Semigroup Monomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Semigroup f â„“â‚) (To : Semigroup t â„“â‚‚) where
  private
    module F = Semigroup From
    module T = Semigroup To

  open Homomorphism F.Data T.Data T._==_

  record IsSemigroupMonomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-magma-monomorphism  : IsMagmaMonomorphism F.magma T.magma ğ•„âŸ¦_âŸ§

    open IsMagmaMonomorphism is-magma-monomorphism public</code></pre>
<h3 id="monoid-monomorphism">Monoid Monomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Monoid f â„“â‚) (To : Monoid t â„“â‚‚) where
  private
    module F = Monoid From
    module T = Monoid To

  open Homomorphism F.Data T.Data T._==_

  record IsMonoidMonomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-semigroup-monomorphism  : IsSemigroupMonomorphism F.semigroup T.semigroup ğ•„âŸ¦_âŸ§
      preserves-identity         : identity-preservation ğ•„âŸ¦_âŸ§ F.Îµ T.Îµ

    open IsSemigroupMonomorphism is-semigroup-monomorphism public</code></pre>
<h3 id="group-monomorphism">Group Monomorphism</h3>
<pre class="agda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Group f â„“â‚) (To : Group t â„“â‚‚) where
  private
    module F = Group From
    module T = Group To

  open Homomorphism F.Data T.Data T._==_

  record IsGroupMonomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-monoid-monomorphism  : IsMonoidMonomorphism F.monoid T.monoid ğ•„âŸ¦_âŸ§
      preserves-inverse       : compose-unary ğ•„âŸ¦_âŸ§ F._â»Â¹ T._â»Â¹

    open IsMonoidMonomorphism is-monoid-monomorphism public</code></pre>
<h2 id="isomorphism">Isomorphism</h2>
<p>Now adding the condition of Surjectivity, we get isomorphisms:</p>
<h3 id="magma-isomorphism">Magma isomorphism</h3>
<pre class="lagda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Magma f â„“â‚) (To : Magma t â„“â‚‚) where
  private
    module F = Magma From
    module T = Magma To

  open Homomorphism F.Data T.Data T._==_

  record IsMagmaIsomorphism (ğ•„âŸ¦_âŸ§ : Morphism) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-magma-monomorphism   : IsMagmaMonomorphism From To ğ•„âŸ¦_âŸ§
      is-morphism-surjective  : Surjective ğ•„âŸ¦_âŸ§</code></pre>
<h3 id="semigroup-isomorphism">Semigroup isomorphism</h3>
<pre class="lagda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Semigroup f â„“â‚) (To : Semigroup t â„“â‚‚) where
  private
    module F = Semigroup From
    module T = Semigroup To

  open Homomorphism F.Data T.Data T._==_

  record IsSemigroupIsomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-magma-isomorphism  : IsMagmaIsomorphism F.magma T.magma ğ•„âŸ¦_âŸ§

    open IsMagmaIsomorphism is-magma-isomorphism public</code></pre>
<h3 id="monoid-isomorphism">Monoid Isomorphism</h3>
<pre class="lagda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Monoid f â„“â‚) (To : Monoid t â„“â‚‚) where
  private
    module F = Monoid From
    module T = Monoid To

  open Homomorphism F.Data T.Data T._==_

  record IsMonoidIsomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-semigroup-isomorphism  : IsSemigroupIsomorphism F.semigroup T.semigroup ğ•„âŸ¦_âŸ§
      preserves-identity         : identity-preservation ğ•„âŸ¦_âŸ§ F.Îµ T.Îµ

    open IsSemigroupIsomorphism is-semigroup-isomorphism public</code></pre>
<h3 id="group-isomorphism">Group Isomorphism</h3>
<pre class="lagda"><code>module _ {f t â„“â‚ â„“â‚‚} (From : Group f â„“â‚) (To : Group t â„“â‚‚) where
  private
    module F = Group From
    module T = Group To

  open Homomorphism F.Data T.Data T._==_

  record IsGroupIsomorphism (ğ•„âŸ¦_âŸ§ : Morphism ) : Set (f âŠ” t âŠ” â„“â‚ âŠ” â„“â‚‚) where
    field
      is-monoid-isomorphism  : IsMonoidIsomorphism F.monoid T.monoid ğ•„âŸ¦_âŸ§
      preserves-inverse       : compose-unary ğ•„âŸ¦_âŸ§ F._â»Â¹ T._â»Â¹

    open IsMonoidIsomorphism is-monoid-isomorphism public</code></pre>
<hr />
<p><a href="./Algebra.rings.html">Rings and family</a></p>
</body>
</html>
