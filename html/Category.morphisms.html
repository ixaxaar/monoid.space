<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Category/morphisms</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<hr />
<p><a href="contents.html">Contents</a> <a href="Category.category.html">Previous</a> <a
href="Category.functors.html">Next</a></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#morphisms">Morphisms</a>
<ul>
<li><a href="#monomorphisms">Monomorphisms</a></li>
<li><a href="#epimorphisms">Epimorphisms</a></li>
<li><a href="#retraction">Retraction</a></li>
<li><a href="#section">Section</a></li>
<li><a href="#endomorphism">Endomorphism</a></li>
<li><a href="#isomorphism">Isomorphism</a></li>
<li><a href="#automorphism">Automorphism</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="morphisms">Morphisms</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Types.product
open import Types.relations
open import Types.equality
open import Category.category

module Category.morphisms where</code></pre>
<p>Morphisms are structure-preserving maps from one mathematical structure to another of the same type. They are a
generalized notion that translates to group homomorphisms for groups, ring homomorphisms for rings, continuous maps for
vector spaces and so on. In the context of category theory, these morphisms have to admit the properties of composition
and associativity.</p>
<h2 id="monomorphisms">Monomorphisms</h2>
<p>A morphism <span class="math inline">\(f : X → Y\)</span> is called a Monomorphism if <span class="math inline">\(f ∘
g_1 = f ∘ g_2\)</span> implies <span class="math inline">\(g_1 = g_2\)</span> for all <span class="math inline">\(g_1,
g_2 : A → X\)</span>. A monomorphism is called “mono” in short and “monic” can be used as an adjective to describe such
a morphism.</p>
<figure>
<img src="/artwork/monic.png" alt="Figure 1: Monomorphism" />
<figcaption aria-hidden="true">Figure 1: Monomorphism</figcaption>
</figure>
<h2 id="epimorphisms">Epimorphisms</h2>
<p>Epimorphisms are dual objects to monomorphisms. A morphism <span class="math inline">\(f : X → Y\)</span> is called
an Epimorphism if <span class="math inline">\(g_1 ∘ f = g_2 ∘ f\)</span> implies <span class="math inline">\(g_1 =
g_2\)</span> for all <span class="math inline">\(g_1, g_2 : Y → A\)</span>. An Epimorphism is called “epi” in short and
“epic” can be used as an adjective to describe such a morphism.</p>
<figure>
<img src="/artwork/epic.png" alt="Figure 2: Epimorphism" />
<figcaption aria-hidden="true">Figure 2: Epimorphism</figcaption>
</figure>
<h2 id="retraction">Retraction</h2>
<p>A morphism <span class="math inline">\(f: X → Y\)</span> has a left inverse if there is a morphism <span
class="math inline">\(g: Y → X\)</span> such that <span class="math inline">\(g ∘ f = id_X\)</span>. The left inverse g
is also called a retraction of f. Morphisms with left inverses are always monomorphisms, but the converse is not true in
general; a monomorphism may fail to have a left inverse. If a retraction exists for a function f, it can also be
expected to be injective.</p>
<h2 id="section">Section</h2>
<p>A morphism <span class="math inline">\(f: X → Y\)</span> has a right inverse if there is a morphism <span
class="math inline">\(g: Y → X\)</span> such that <span class="math inline">\(f ∘ g = id_Y\)</span>. The right inverse g
is also called a section of f. Morphisms having a right inverse are always epimorphisms, but the converse is not true in
general, as an epimorphism may fail to have a right inverse. If a section exists for a function f, it can also be
expected to be surjective.</p>
<h2 id="endomorphism">Endomorphism</h2>
<p>Endomorphisms are morphisms with the same source and target, <span class="math inline">\(f : X → X\)</span>.</p>
<h2 id="isomorphism">Isomorphism</h2>
<p>A morphism <span class="math inline">\(f : X → Y\)</span> is called an isomorphism if there exists a unique morphism
<span class="math inline">\(g: Y → X\)</span> such that <span class="math inline">\(f ∘ g = id_Y\)</span> and <span
class="math inline">\(g ∘ f = id_X\)</span>. If a morphism has both left-inverse and right-inverse, then the two
inverses are equal, so f is an isomorphism, and g is called simply the inverse of f.</p>
<h2 id="automorphism">Automorphism</h2>
<p>An automorphism is both an endomorphism and an isomorphism.</p>
<hr />
<p><a href="./Category.functors.html">Functors</a></p>
</body>
</html>
