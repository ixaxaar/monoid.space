<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algebra/numbers</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-lean@1.2.0/dist/lean.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      // The lean.min.js automatically registers the 'lean' language with hljs

      // Fix Pandoc's class names for all code blocks
      // Pandoc with --no-highlight outputs: <pre class="LANGUAGE"><code>...</code></pre>
      // highlight.js expects: <pre><code class="language-LANGUAGE">...</code></pre>
      document.querySelectorAll('pre[class]').forEach((preBlock) => {
        const lang = preBlock.className;
        if (lang) {
          const codeBlock = preBlock.querySelector('code');
          if (codeBlock && !codeBlock.className) {
            codeBlock.classList.add('language-' + lang);
          }
        }
      });

      // Highlight all code blocks
      hljs.highlightAll();
    });
  </script>
</head>
<body>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#numbers">Numbers</a>
<ul>
<li><a href="#natural-numbers">Natural numbers</a></li>
<li><a href="#integers">Integers</a></li>
<li><a href="#rational-numbers">Rational numbers</a></li>
<li><a href="#real-numbers">Real Numbers</a>
<ul>
<li><a href="#dedekind-cuts">Dedekind cuts</a></li>
<li><a href="#cauchy-sequences">Cauchy sequences</a></li>
<li><a href="#real-numbers">Real numbers</a></li>
</ul></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<hr />
<p><a href="contents.html">Contents</a> <a href="Algebra.rings.html">Previous</a> <a
href="./HoTT.introduction.html">Next</a></p>
<h1 id="numbers">Numbers</h1>
<pre class="agda"><code>open import Agda.Primitive using (Level; _⊔_; lsuc; lzero)

open import Logic.logicBasics using (if_then_else_)
open import Lang.dataStructures using (Bool; true; false)

open import Types.product
open import Types.relations
open import Types.equality

module Algebra.numbers {a ℓ} {A : Set a} (_==_ : Rel A ℓ) where
  open import Types.operations (_==_)

  open import Algebra.order (_==_)
  open import Algebra.groups (_==_)
  open import Algebra.rings (_==_)
  open import Algebra.fields (_==_)</code></pre>
<p>In the previous sections we looked at structures, starting from the very simple groups and monoids, which comprise of
a type and one binary operation to fields of a type and two binary operations. We now look at how to construct the most
known objects in all of mathematics: numbers.</p>
<h2 id="natural-numbers">Natural numbers</h2>
<p>Natural numbers are integral numbers greater than 0, e.g. <code>1, 2, 3, 4, ... ∈ ℕ</code>. Note that infinity
<code>∞</code> is not a natural number. They are the easiest to construct among the numbers and as a successive pattern
of creation is all the structure that is required:</p>
<pre class="agda"><code>  data ℕ : Set where
    0# : ℕ
    succ : ℕ → ℕ

  _+_ : ℕ → ℕ → ℕ
  x + 0# = x
  x + (succ y) = succ (x + y)

  _−_ : ℕ → ℕ → ℕ
  0#  − m     = 0#
  succ n − 0#  = succ n
  succ n − succ m = n − m

  _✖_ : ℕ → ℕ → ℕ
  x ✖ 0#     = 0#
  x ✖ (succ y) = x + (x ✖ y)

  _&lt;_ : ℕ → ℕ → Bool
  0# &lt; succ x = true
  x &lt; 0# = false
  succ x &lt; succ y = x &lt; y</code></pre>
<p>Note that we cannot define division operation on natural numbers as the output may not be a natural number.</p>
<h2 id="integers">Integers</h2>
<p>Integers can either be positive or negative natural numbers.</p>
<pre class="agda"><code>  data ℤ : Set where
    pos : (n : ℕ) → ℤ
    neg : (n : ℕ) → ℤ

  _⊕_ : ℤ → ℤ → ℤ
  pos x ⊕ pos y = pos (x + y)
  pos x ⊕ neg y = if (x &lt; y) then neg (y − x) else pos (x − y)
  neg x ⊕ pos y = if (y &lt; x) then neg (x − y) else pos (y − x)
  neg x ⊕ neg y = neg (x + y)

  _⊖_ : ℤ → ℤ → ℤ
  pos x ⊖ pos y = if (y &lt; x) then pos (x − y) else neg (y − x)
  pos x ⊖ neg y = pos (x + y)
  neg x ⊖ pos y = neg (x + y)
  neg x ⊖ neg y = if (x &lt; y) then neg (y − x) else pos (x − y)

  _⊗_ : ℤ → ℤ → ℤ
  pos x ⊗ pos y = pos (x ✖ y)
  pos x ⊗ neg y = neg (x ✖ y)
  neg x ⊗ pos y = neg (x ✖ y)
  neg x ⊗ neg y = pos (x ✖ y)

  _⧀_ : ℤ → ℤ → Bool
  pos x ⧀ pos y = x &lt; y
  pos x ⧀ neg y = false
  neg x ⧀ pos y = true
  neg x ⧀ neg y = y &lt; x</code></pre>
<h2 id="rational-numbers">Rational numbers</h2>
<p>A rational number is a quotient or fraction of two integers:</p>
<pre class="agda"><code>  data ℚ : Set where
    _⨸_ : ℤ → ℤ → ℚ

  numerator : ℚ → ℤ
  numerator (n ⨸ d) = n

  denominator : ℚ → ℤ
  denominator (n ⨸ d) = d

  _⊞_ : ℚ → ℚ → ℚ
  (a ⨸ b) ⊞ (c ⨸ d) = ((a ⊗ d) ⊕ (c ⊗ b)) ⨸ (b ⊗ d)

  _⊟_ : ℚ → ℚ → ℚ
  (a ⨸ b) ⊟ (c ⨸ d) = ((a ⊗ d) ⊖ (c ⊗ b)) ⨸ (b ⊗ d)

  _⧆_ : ℚ → ℚ → ℚ
  (a ⨸ b) ⧆ (c ⨸ d) = (a ⊗ c) ⨸ (b ⊗ d)

  _⧄_ : ℚ → ℚ → ℚ
  (a ⨸ b) ⧄ (c ⨸ d) = (a ⊗ d) ⨸ (b ⊗ c)

  _⪦_ : ℚ → ℚ → Bool
  (a ⨸ b) ⪦ (c ⨸ d) = ((a ⊗ d) ⧀ (c ⊗ b))</code></pre>
<h2 id="real-numbers">Real Numbers</h2>
<p>The rational numbers, when represented using digits (0-9), can either be of finite decimal places, or of infinite
decimal places but repetitive (e.g. 4.35353535…). Note that the denominator cannot be zero, as ∞ is not a rational
number (it’s not considered to be any kind of number). Since rational numbers can be added, multiplied, subtracted and
divided using integer operations all resulting in rational numbers, they form a field.</p>
<p>We know all of the above kinds of numbers as represented with a string of digits <code>0-9</code> e.g. 3724765.1245.
In other words, if we were to take the ten digits and arrange them in a certain order, we would get an integer. Same
remains true for rational numbers, though they require two integers. Though this “decimal” representation of numbers are
almost unanimously used, they are difficult to work with in mathematics. Hence alternate representations, which tend to
be easier, are preferred, though the decimal representations have been shown to follow all the rules of the above
definitions.</p>
<p>Real numbers, which include the natural numbers, integers, rational and irrational numbers, are harder to construct
as compared to natural numbers. Real numbers, as they include irrational numbers, are numbers with infinite precision.
Consider the simplest operation on these numbers: addition: the traditional way of adding two numbers - starting from
the right-most decimal, becomes impossible as in case of arbitrary precision numbers there is no right-most digit!
Natural numbers, integers and rational numbers are discrete systems and do not face this problem of infinity. We
therefore need to define real numbers using another, more manageable representation - as complete ordered fields. The
completeness here can imply two different things - Cauchy and Dedekind completeness, either of which when satisfied,
satisfies the other and we can then call the objects of the ordered field “real numbers”.</p>
<h3 id="dedekind-cuts">Dedekind cuts</h3>
<h3 id="cauchy-sequences">Cauchy sequences</h3>
<p>The constructive definition of a real number is based on the algebraic object “Fields” we saw in the last section.
There we first defined fields, followed by fields with ordering, also called “Ordered Fields”. We now use the
definitions of ordered fields to construct real numbers. As a byproduct, we also show how to construct complex and
rational numbers.</p>
<h3 id="real-numbers-1">Real numbers</h3>
<p>Real numbers and their two operations, + and -, form a field. There are a few additional restrictions imposed on how
+ and - are to behave with ≤. Real numbers represent:</p>
<ul>
<li>A set $ ℝ $</li>
<li>Two binary operations: + and −</li>
</ul>
<p>where the structure defined on the operations are:</p>
<ol type="1">
<li>$ ℝ $ is a field under addition and multiplication, which implies:</li>
</ol>
<ul>
<li>$ ℝ $ is an abelian group under addition, which implies the operation +:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an inverse (−)</li>
<li>has an identity</li>
</ul></li>
<li>$ ℝ $ is a monoid under multiplication, which implies the operation *:
<ul>
<li>is associative</li>
<li>is commutative</li>
<li>has an inverse (÷)</li>
<li>has an identity</li>
</ul></li>
<li>Multiplication is distributive over addition</li>
<li>There must be an annihilating element 𝕖 such that $ ∀ x : 𝕖 ★ x = 𝕖 $</li>
</ul>
<ol start="2" type="1">
<li>$ ℝ $ forms a totally ordered set over ≤, which implies ≤ is:</li>
</ol>
<ul>
<li>reflexive</li>
<li>antisymmetric</li>
<li>transitive</li>
<li>total</li>
</ul>
<ol start="3" type="1">
<li>Addition and multiplication are compatible with ≤:</li>
</ol>
<ul>
<li>addition preserves order <code>if x ≤ y then x + ε ≤ y + ε</code></li>
<li>multiplication preserves order <code>if 0 ≤ x and 0 ≤ y then 0 ≤ x * y</code></li>
</ul>
<ol start="4" type="1">
<li>The order ≤ is “complete” or without gaps, also known as “Dedekind completeness”, which states that for every subset
𝕣 of ℝ, there exists an 𝕩 ∈ ℝ, such that $ 𝕩 = sup (𝕣) $ or 𝕩 is the least upper bound of 𝕣.</li>
</ol>
<pre class="agda"><code>  record IsRealNumber (_+_ _*_ : ★ A) (-_ ÷_ : ♠ A) (_≤_ : Rel A ℓ) (0# 1# : A) : Set (a ⊔ ℓ) where
    field
      isOrderedField   : IsOrderedField _+_ _*_ -_ ÷_ _≤_ 0# 1#
      +-preservesOrder : ∀ n → (_+ n) Preserves _≤_ ⟶ _≤_
      *-preservesOrder : (_* 0#) Preserves _≤_ ⟶ _≤_

    open IsOrderedField isOrderedField public</code></pre>
<hr />
<p><a href="./HoTT.introduction.html">HoTT Introduction</a></p>
</body>
</html>
