<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>equational.lagda</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/agda.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<hr />
<ul>
<li><a href="#equational-reasoning">Equational Reasoning</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<hr />
<p><a href="contents.html">Contents</a></p>
<h1 id="equational-reasoning">Equational Reasoning</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> Types<span class="ot">.</span>equational <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">open</span> <span class="kw">import</span> Lang<span class="ot">.</span>dataStructures <span class="kw">using</span> <span class="ot">(</span>ℕ<span class="ot">;</span> zero<span class="ot">;</span> one<span class="ot">;</span> succ<span class="ot">;</span> <span class="ot">_</span>+<span class="ot">_;</span> <span class="ot">_</span>−<span class="ot">_;</span> <span class="ot">_</span>×<span class="ot">_;</span> <span class="ot">_</span>^<span class="ot">_)</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">open</span> <span class="kw">import</span> Agda<span class="ot">.</span>Primitive <span class="kw">using</span> <span class="ot">(</span>Level<span class="ot">;</span> <span class="ot">_</span>⊔<span class="ot">_;</span> lsuc<span class="ot">;</span> lzero<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>equality</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">open</span> <span class="kw">import</span> Types<span class="ot">.</span>product <span class="kw">using</span> <span class="ot">(</span>Σ<span class="ot">;</span> <span class="ot">_</span>,<span class="ot">_)</span> <span class="kw">renaming</span> <span class="ot">(_</span>×<span class="ot">_</span> <span class="kw">to</span> <span class="ot">_</span>and<span class="ot">_)</span></a></code></pre></div>
<p>Though we looked at the type theory way of constructively proving propositions, there is another way which we tend to be more familiar with: the way we solve equations on paper. However, note that in practice, “type-hackers”, tend to use a combination of both constructive and equational as per convenience as well see below.</p>
<p>For example, consider the problem of proving a well known identity from linear algebra:</p>
<pre class="math"><code>∀ a, b ∈ ℕ: (a+b) × (a-b) ≡ a² - b²

(a + b) × (a - b)
    Applying distributivity of + and × (a + b) * c ≡ (a × c) + (b × c)
 = a × (a - b) + b × (a - b)
    Applying distributivity again, this time from the left-hand side
 = a × a - a × b + b × a - b²
    Applying
        1. The fact that a × a ≡ a²
        2. Commutativity of multiplication: a × b ≡ b × a
        3. Reflexivity of ≡ for a × b and b × a to cancel each other out
= a² - b²
Q.E.D.</code></pre>
<p>Each step of such a solution essentially follows through the rule of transitivity of equality. Hence setp₂ = step₁ + actions₁ and so on. We can write an apparatus to let us do exactly that in Agda. That apparatus is “equational reasoning”. Here, we define the framework on top of equivalence relations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">module</span> ≡-Reasoning <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>≡<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="ot">(</span>Eq <span class="ot">:</span> IsEquivalence <span class="ot">_</span>≡<span class="ot">_)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">open</span> IsEquivalence Eq</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="kw">infix</span>  <span class="dv">3</span> <span class="ot">_</span>∎</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>≡⟨⟩<span class="ot">_</span> <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="kw">infix</span>  <span class="dv">1</span> begin<span class="ot">_</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="co">-- This is just syntactical sugar to define the start of the proof</span></a>
<a class="sourceLine" id="cb3-9" title="9">  begin<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀{</span>x y <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> x ≡ y</a>
<a class="sourceLine" id="cb3-10" title="10">  begin<span class="ot">_</span> x≡y <span class="ot">=</span> x≡y</a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="co">-- Apply reflexivity, no axioms or theorems applied within the ⟨⟩</span></a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="ot">_</span>≡⟨⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> x ≡ y</a>
<a class="sourceLine" id="cb3-14" title="14">  <span class="ot">_</span> ≡⟨⟩ x≡y <span class="ot">=</span> x≡y</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">  <span class="co">-- Transitivity with axioms and theorems applied within the ⟨⟩</span></a>
<a class="sourceLine" id="cb3-17" title="17">  <span class="ot">_</span>≡⟨<span class="ot">_</span>⟩<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">{</span>y z<span class="ot">}</span> <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ y <span class="ot">→</span> y ≡ z <span class="ot">→</span> x ≡ z</a>
<a class="sourceLine" id="cb3-18" title="18">  <span class="ot">_</span> ≡⟨ x≡y ⟩ y≡z <span class="ot">=</span> trans x≡y y≡z</a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20">  <span class="co">-- The QED or &quot;hence, proved&quot; marker to end the proof.</span></a>
<a class="sourceLine" id="cb3-21" title="21">  <span class="ot">_</span>∎ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> x ≡ x</a>
<a class="sourceLine" id="cb3-22" title="22">  <span class="ot">_</span>∎ <span class="ot">_</span> <span class="ot">=</span> rfl</a></code></pre></div>
<p>In order to define <span class="math inline">\((a+b) × (a-b) ≡ a² - b²\)</span> in Agda, we have to define some properties of <code>+</code>, <code>-</code> and <code>*</code>:</p>
<ul>
<li>Distributivity of <code>+</code> over <code>×</code> from the right side</li>
<li>Distributivity of <code>+</code> over <code>×</code> from the left side</li>
<li>Commutativity of <code>×</code></li>
<li>Reflexivity of <code>≡</code></li>
</ul>
<p>We dont need to prove the reflexivity of <code>≡</code> as it is a part of our equational reasoning framework as has been already assumed.</p>
<p>We begin by defining that <code>Commutativity</code> and <code>Distributivity</code> are:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">module</span> Properties <span class="ot">{</span>a ℓ<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> Rel A ℓ<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  ★<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">→</span> <span class="dt">Set</span> a <span class="ot">→</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb4-3" title="3">  ★ A <span class="ot">=</span> A <span class="ot">→</span> A <span class="ot">→</span> A</a></code></pre></div>
<p><strong>Commutativity</strong>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" title="1">  Commutative <span class="ot">:</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" title="2">  Commutative <span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y <span class="ot">→</span> <span class="ot">(</span>x ∙ y<span class="ot">)</span> == <span class="ot">(</span>y ∙ x<span class="ot">)</span></a></code></pre></div>
<p><strong>Distributivity</strong>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" title="1">  <span class="co">-- distributive from the left side</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="ot">_</span>DistributesOverˡ<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="ot">_</span>*<span class="ot">_</span> DistributesOverˡ <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">(</span>x * <span class="ot">(</span>y + z<span class="ot">))</span> == <span class="ot">((</span>x * y<span class="ot">)</span> + <span class="ot">(</span>x * z<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="co">-- distributive from the right side</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="ot">_</span>DistributesOverʳ<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="ot">_</span>*<span class="ot">_</span> DistributesOverʳ <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">=</span> <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">((</span>y + z<span class="ot">)</span> * x<span class="ot">)</span> == <span class="ot">((</span>y * x<span class="ot">)</span> + <span class="ot">(</span>z * x<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="co">-- encapsulates both of the above</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="ot">_</span>DistributesOver<span class="ot">_</span> <span class="ot">:</span> ★ A <span class="ot">→</span> ★ A <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb6-11" title="11">  * DistributesOver + <span class="ot">=</span> <span class="ot">(</span>* DistributesOverˡ +<span class="ot">)</span> and <span class="ot">(</span>* DistributesOverʳ +<span class="ot">)</span></a></code></pre></div>
<p>Next, we prove the commutativity of <code>×</code>: For this we need to start with proving the commutativity of <code>+</code> as <code>×</code> is defined on it:</p>
<pre class="askneagda"><code>open Properties {A = ℕ} _≡_

comm-+ : Commutative _+_
comm-+ </code></pre>
<pre class="kdsewofagda"><code>-- comm-× : Commutative _×_
-- comm-× a zero = zero a
-- comm-× a (succ b) =</code></pre>
<hr />
<p><a href="./Logic.introduction.html">Logic Introduction</a></p>
</body>
</html>
